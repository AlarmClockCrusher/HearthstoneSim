Inspecting Basic.py
class Trig_HealingTotem(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["TurnEnds"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "At the end of turn, %s restores 1 health to all friendly minions."%self.entity.name)
		heal = 1 * (2 ** self.entity.countHealDouble())
		targets = self.entity.Game.minionsonBoard(self.entity.ID)
		self.entity.restoresAOE(targets, [heal for minion in targets])
		
		
class Trig_GurubashiBerserker(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["MinionTakesDmg"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return target == self.entity and self.entity.onBoard
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "%s takes Damage and gains +3 Attack."%self.entity.name)
		self.entity.buffDebuff(3, 0)
		
		
class Trig_SatyrOverseer(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["HeroAttackedMinion", "HeroAttackedHero"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and subject == self.entity.Game.heroes[self.entity.ID]
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "After friendly hero attacks, %s summons a 2/2 Satyr"%self.entity.name)
		self.entity.Game.summon(IllidariSatyr(self.entity.Game, self.entity.ID), self.entity.position+1, self.entity.ID)
		
class Trig_StarvingBuzzard(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["MinionSummoned"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and self.entity.health > 0 and subject.ID == self.entity.ID and "Beast" in subject.race and subject != self.entity
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "A friendly Beast is summoned and %s lets player draw a card."%self.entity.name)
		self.entity.Game.Hand_Deck.drawCard(self.entity.ID)
		
		
class Trig_WaterElemental(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["MinionTakesDmg", "HeroTakesDmg"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return subject == self.entity
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "%s deals damage to %s and freezes it."%(self.entity.name, target.name))
		target.getsFrozen()
		
		
class Trig_TruesilverChampion(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["HeroAttackingMinion", "HeroAttackingHero"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return subject == self.entity.Game.heroes[self.entity.ID] and self.entity.onBoard
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		heal = 2 * (2 ** self.entity.countHealDouble())
		PRINT(self.entity.Game, "%s restores %d Health the hero when it attacks."%(self.entity.name, heal))
		self.entity.restoresHealth(self.entity.Game.heroes[self.entity.ID], heal)
		
		
class Trig_Corruption(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["TurnStarts"])
		self.inherent = False
		self.ID = 1
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and ID == self.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "At the start of player %d's turn, Corrupted minion %s dies."%(self.ID, self.entity.name))
		self.entity.Game.killMinion(None, self.entity)
		self.disconnect()
		extractfrom(self, self.entity.trigsBoard)
		
	def selfCopy(self, recipient):
		trig = type(self)(recipient)
		trig.ID = self.ID
		return trig
		
class Trig_Charge(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["TurnEnds"])
		self.inherent = False
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard #Even if the current turn is not minion's owner's turn
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "At the end of turn, minion %s can attack hero again."%self.entity.name)
		self.entity.marks["Can't Attack Hero"] -= 1
		self.disconnect()
		try: self.entity.trigsBoard.remove(self)
		except: pass
		
		
Inspecting Classic.py
class Trig_LightWarden(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["MinionGetsHealed", "HeroGetsHealed"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "A character is healed and %s gains +2 attack."%self.entity.name)
		self.entity.buffDebuff(2, 0)
		
		
class Trig_MurlocTidecaller(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["MinionSummoned"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and subject.ID == self.entity.ID and "Murloc" in subject.race and subject != self.entity
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "A friendly Murloc %s is summoned and %s gains +1 attack."%(subject.name, self.entity.name))
		self.entity.buffDebuff(1, 0)
		
#When the secret is countered by the Couterspell, Secretkeeper doesn't respond.
#Neither does Questing Adventurer.
class Trig_Secretkeeper(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["SpellPlayed"])
		
	#Assume Secretkeeper and trigger while dying.
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and subject.description.startswith("Secret:")
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "A Secret is played and %s gains 1/+1."%self.entity.name)
		self.entity.buffDebuff(1, 1)
		
		
class Trig_YoungPriestess(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["TurnEnds"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		curGame = self.entity.Game
		if curGame.mode == 0:
			if curGame.guides:
				i = curGame.guides.pop(0)
			else:
				minions = curGame.minionsonBoard(self.entity.ID)
				try: minions.remove(self.entity)
				except: pass
				i = npchoice(minions).position if minions else -1
				curGame.fixedGuides.append(i)
			if i > -1:
				minion = curGame.minions[self.entity.ID][i]
				PRINT(curGame, "At the end of turn, Young Priestess gvies another random friendly minion %s +1 Health."%minion.name)
				minion.buffDebuff(0, 1)
				
"""mana 2 minions"""
class Trig_Doomsayer(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["TurnStarts"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "At the start of turn, %s destroys all minions"%self.entity.name)
		self.entity.Game.killMinion(self.entity, self.entity.Game.minionsonBoard(1) + self.entity.Game.minionsonBoard(2))
		
		
class Trig_KnifeJuggler(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["MinionBeenSummoned"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and subject.ID == self.entity.ID and subject != self.entity
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		curGame = self.entity.Game
		if curGame.mode == 0:
			enemy = None
			if curGame.guides:
				i, where = curGame.guides.pop(0)
				if where: enemy = curGame.find(i, where)
			else:
				chars = curGame.charsAlive(3-self.entity.ID)
				if chars:
					enemy = npchoice(chars)
					curGame.fixedGuides.append((enemy.position, enemy.type+str(enemy.ID)))
				else:
					curGame.fixedGuides.append((0, ''))
			if enemy:
				PRINT(curGame, "A friendly minion %s is summoned and Knife Juggler deals 1 damage to random enemy %s"%(subject.name, enemy.name))
				self.entity.dealsDamage(enemy, 1)
				
				
class Trig_LorewalkerCho(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["SpellPlayed"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "Spell %s is cast and Lorewalker Cho gives the other player a copy of it"%subject.name)
		card = type(subject)(self.entity.Game, 3-subject.ID)
		self.entity.Game.Hand_Deck.addCardtoHand(card, 3-subject.ID)
		
		
class Trig_ManaAddict(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["SpellPlayed"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and subject.ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "Player casts a spell and Mana Addict gains +2 attack this turn.")
		self.entity.buffDebuff(2, 0, "EndofTurn")
		
		
class Trig_MasterSwordsmith(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["TurnEnds"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		curGame = self.entity.Game
		if curGame.mode == 0:
			if curGame.guides:
				i = curGame.guides.pop(0)
			else:
				minions = curGame.minionsonBoard(self.entity.ID)
				try: minions.remove(self.entity)
				except: pass
				i = npchoice(minions).position if minions else -1
				curGame.fixedGuides.append(i)
			if i > -1:
				minion = curGame.minions[self.entity.ID][i]
				PRINT(curGame, "At the end of turn, Master Swordsmith gvies another random friendly minion %s +1 Attack."%minion.name)
				minion.buffDebuff(1, 0)
				
				
#不同于洛欧塞布，米尔豪斯的法力值会在战吼之后马上生效。
class Trig_NatPagle(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["TurnStarts"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and ID == self.entity.ID
		
	#不确定纳特帕格是直接让玩家摸一张牌还是确定多摸之后在后续的抽牌阶段摸一张。
	#暂时假设是直接摸一张牌。
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		curGame = self.entity.Game
		if curGame.mode == 0:
			PRINT(self.entity.Game, "At the start of turn, Nat Pagle has 50% chance to lets player draw a card.")
			if curGame.guides:
				bitBait = curGame.guides.pop(0)
			else:
				bitBait = nprandint(2)
				curGame.fixedGuides.append(bitBait)
			if bitBait:
				PRINT(curGame, "Nat Pagle lets player draw a card.")
				curGame.Hand_Deck.drawCard(self.entity.ID)
				
				
class Trig_WildPyromancer(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["SpellBeenPlayed"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and subject.ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "After player casts a spell, Wild Pyromancer deals 1 damage to all minions.")
		targets = self.entity.Game.minionsonBoard(1) + self.entity.Game.minionsonBoard(2)
		self.entity.dealsAOE(targets, [1 for minion in targets])
		
		
class Trig_AlarmoBot(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["TurnStarts"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		minion, curGame = self.entity, self.entity.Game
		ownHand = curGame.Hand_Deck.hands[self.entity.ID]
		if curGame.mode == 0:
			if curGame.guides:
				i = curGame.guides.pop(0)
			else:
				minions = [i for i, card in enumerate(ownHand) if card.type == "Minion"]
				i = npchoice(minions) if minions and curGame.space(minion.ID) > 0 else -1
				curGame.fixedGuides.append(i)
			if i > -1:
				PRINT(curGame, "At the start of turn, Alarm-o-Bot swaps with random minion in player's hand")
				#需要先把报警机器人自己从场上移回手牌
				ID, inOrigDeck, pos = minion.ID, minion.inOrigDeck, minion.position
				minion.disappears(deathrattlesStayArmed=False)
				self.removeMinionorWeapon(minion)
				minion.__init__(self, ID)
				minion.inOrigDeck = inOrigDeck
				PRINT(curGame, "%s has been reset after returned to owner's hand. All enchantments lost."%minion.name)
				#下面节选自Hand.py的addCardtoHand方法，但是要跳过手牌已满的检测
				ownHand.append(minion)
				minion.entersHand()
				curGame.sendSignal("CardEntersHand", minion, None, [minion], 0, "")
				#假设先发送牌进入手牌的信号，然后召唤随从
				curGame.summonfromHand(i, ID, pos, ID)
				
				
class Trig_Demolisher(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["TurnStarts"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		curGame = self.entity.Game
		if curGame.mode == 0:
			enemy = None
			if curGame.guides:
				i, where = curGame.guides.pop(0)
				if where: enemy = curGame.find(i, where)
			else:
				targets = curGame.charsAlive(3-self.entity.ID)
				if targets:
					enemy = npchoice(targets)
					curGame.fixedGuides.append((enemy.position, enemy.type+str(enemy.ID)))
				else:
					curGame.fixedGuides.append((0, ''))
			if enemy: self.entity.dealsDamage(enemy, 2)
			
			
class Trig_FlesheatingGhoul(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["MinionDies"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and target != self.entity #Technically, minion has to disappear before dies. But just in case.
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "A minion %s dies and %s gains +1 attack."%(target.name, self.entity.name))
		self.entity.buffDebuff(1, 0)
		
		
class Trig_ImpMaster(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["TurnEnds"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "At the end of turn, %s deals 1 damage to itself and summons a 1/1 Imp."%self.entity.name)
		self.entity.dealsDamage(self.entity, 1)
		self.entity.Game.summon(Imp(self.entity.Game, self.entity.ID), self.entity.position+1, self.entity.ID)
		
class Trig_QuestingAdventurer(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["MinionPlayed", "SpellPlayed", "WeaponPlayed", "HeroCardPlayed"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and subject.ID == self.entity.ID and subject != self.entity
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "Player plays a card and %s gains +1/+1."%self.entity.name)
		self.entity.buffDebuff(1, 1)
		
		
class Trig_CultMaster(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["MinionDies"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and target != self.entity and target.ID == self.entity.ID#Technically, minion has to disappear before dies. But just in case.
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "A friendly minion %s dies and %s lets player draw a card."%(target.name, self.entity.name))
		self.entity.Game.Hand_Deck.drawCard(self.entity.ID)
		
		
class Trig_DreadCorsair(TrigHand):
	def __init__(self, entity):
		self.blank_init(entity, ["WeaponEquipped", "WeaponRemoved", "WeaponAttChanges"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.inHand and ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		self.entity.Game.Manas.calcMana_Single(self.entity)
		
		
class Trig_VioletTeacher(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["SpellPlayed"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and subject.ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "Player casts a spell and %s summons a 1/1 Violet Apprentice."%self.entity.name)
		self.entity.Game.summon(VioletApprentice(self.entity.Game, self.entity.ID), self.entity.position+1, self.entity.ID)
		
class Trig_GadgetzanAuctioneer(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["SpellPlayed"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and subject.ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "Player casts a spell and %s lets player draw a card."%self.entity.name)
		self.entity.Game.Hand_Deck.drawCard(self.entity.ID)
		
		
class Trig_Hogger(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["TurnEnds"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "At the end of turn, %s summons a 2/2 Gnoll with Taunt."%self.entity.name)
		self.entity.Game.summon(Gnoll(self.entity.Game, self.entity.ID), self.entity.position+1, self.entity.ID)
		
class Trig_Xavius(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["MinionPlayed", "SpellPlayed", "WeaponPlayed", "HeroCardPlayed"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and subject.ID == self.entity.ID and subject != self.entity
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "Player plays a card and %s summons a 2/1 XavianSatyr."%self.entity.name)
		self.entity.Game.summon(XavianSatyr(self.entity.Game, self.entity.ID), self.entity.position+1, self.entity.ID)		
		
class Trig_BaronGeddon(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["TurnEnds"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "At the end of turn, %s deals 2 damage to ALL other characters."%self.entity.name)
		targets = [self.entity.Game.heroes[1], self.entity.Game.heroes[2]] + self.entity.Game.minionsonBoard(1) + self.entity.Game.minionsonBoard(2)
		extractfrom(self.entity, targets)
		self.entity.dealsAOE(targets, [2 for obj in targets])
		
		
class Trig_ArcaneDevourer(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["SpellPlayed"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and subject.ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "Player casts a spell and %s gains +2/+2."%self.entity.name)
		self.entity.buffDebuff(2, 2)
		
		
class Trig_Gruul(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["TurnEnds"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "At the end of each turn, %s gains +1/+1."%self.entity.name)
		self.entity.buffDebuff(1, 1)
		
"""Mana 9 minions"""
class Trig_Ysera(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["TurnEnds"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		curGame = self.entity.Game
		if curGame.mode == 0:
			if curGame.guides:
				card = curGame.guides.pop(0)
			else:
				card = npchoice([Dream, Nightmare, YseraAwakens, LaughingSister, EmeraldDrake])
				curGame.fixedGuides.append(card)
			PRINT(curGame, "At the end of turn, Ysera adds a Dream Card into player's hand.")
			curGame.Hand_Deck.addCardtoHand(card, self.entity.ID, "type")
			
class Trig_SeaGiant(TrigHand):
	def __init__(self, entity):
		self.blank_init(entity, ["MinionAppears", "MinionDisappears"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.inHand
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		self.entity.Game.Manas.calcMana_Single(self.entity)
		
"""Druid Cards"""
class Trig_ExplosiveTrap(SecretTrigger):
	def __init__(self, entity):
		self.blank_init(entity, ["HeroAttacksHero", "MinionAttacksHero"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0): #target here holds the actual target object
		return self.entity.ID != self.entity.Game.turn and target[0] == self.entity.Game.heroes[self.entity.ID]
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		damage = (2 + self.entity.countSpellDamage()) * (2 ** self.entity.countDamageDouble())
		PRINT(self.entity.Game, "When player is attacked, Secret Explosive Trap is triggered and deals %d damage to all enemies."%damage)
		enemies = [self.entity.Game.heroes[3-self.entity.ID]] + self.entity.Game.minionsonBoard(3-self.entity.ID)
		self.entity.dealsAOE(enemies, [damage for obj in enemies])
		
		
class Trig_FreezingTrap(SecretTrigger):
	def __init__(self, entity):
		self.blank_init(entity, ["MinionAttacksMinion", "MinionAttacksHero"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.ID != self.entity.Game.turn and subject.type == "Minion" and subject.ID != self.entity.ID \
				and subject.onBoard and subject.health > 0 and not subject.dead #The attacker must be onBoard and alive to be returned to hand
				
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "When enemy minion %s attacks, Secret Freezing Trap is triggered and returns it to its owner's hand."%subject.name)
		#假设那张随从在进入手牌前接受-2费效果。可以被娜迦海巫覆盖。
		manaMod = ManaMod(subject, changeby=+2, changeto=-1)
		self.entity.Game.returnMiniontoHand(subject, deathrattlesStayArmed=False, manaMod=manaMod)
		
		
class Trig_Misdirection(SecretTrigger):
	def __init__(self, entity):
		self.blank_init(entity, ["HeroAttacksHero", "MinionAttacksHero"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0): #target here holds the actual target object
		#The target needs to be your hero
		if self.entity.ID != self.entity.Game.turn and target[0].type == "Hero" and target[0].ID == self.entity.ID \
			and subject.onBoard and subject.health > 0 and not subject.dead: #The attacker must be onBoard and alive to continue
			targets = self.entity.Game.charsAlive(1) + self.entity.Game.charsAlive(2)
			extractfrom(subject, targets)
			extractfrom(target[1], targets)
			if targets: return True
		return False
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		curGame = self.entity.Game
		if curGame.mode == 0:
			PRINT(curGame, "When player is attacked, Secret Misdirection is triggered and redirects the attack to another target %s"%target[1].name)
			if curGame.guides:
				i, where = curGame.guides.pop(0)
				if where: target[1] = curGame.find(i, where)
			else:
				targets = self.entity.Game.charsAlive(1) + self.entity.Game.charsAlive(2)
				try: targets.remove(subject)
				except: pass
				try: targets.remove(target[1]) #误导始终是根据当前的真实攻击目标进行响应。即使本轮中初始的的攻击目标不与当前的目标一致。
				except: pass
				if targets:
					target[1] = npchoice(targets)
					curGame.fixedGuides.append((target[1].position, target[1].type+str(target[1].ID)))
				else:
					curGame.fixedGuides.append((0, ''))
					
					
class Trig_SnakeTrap(SecretTrigger):
	def __init__(self, entity):
		self.blank_init(entity, ["MinionAttacksMinion", "HeroAttacksMinion"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0): #target here holds the actual target object
		#The target has to a friendly minion and there is space on board to summon minions.
		return self.entity.ID != self.entity.Game.turn and target[0].type == "Minion" and target[0].ID == self.entity.ID and self.entity.Game.space(self.entity.ID) > 0
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "When a friendly minion %s is attacked, Secret Snake Trap is triggered and summons three 1/1 Snakes."%target[0].name)
		self.entity.Game.summon([Snake(self.entity.Game, self.entity.ID) for i in range(3)], (-1, "totheRightEnd"), self.entity.ID)
		
class Trig_Snipe(SecretTrigger):
	def __init__(self, entity):
		self.blank_init(entity, ["MinionBeenPlayed"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		#不确定是否只会对生命值大于1的随从触发。一般在"MinionBeenPlayed"信号发出的时候随从都是处于非濒死状态的。
		return self.entity.ID != self.entity.Game.turn and subject.ID != self.entity.ID and subject.health > 0 and subject.dead == False
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		damage = (4 + self.entity.countSpellDamage()) * (2 ** self.entity.countDamageDouble())
		PRINT(self.entity.Game, "After enemy minion %s is played, Secret Snipe is triggered and deals %d damage to it."%(subject.name, damage))
		self.entity.dealsDamage(subject, damage)
		
		
class Trig_ScavengingHyena(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["MinionDies"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		#Technically, minion has to disappear before dies. But just in case.
		return self.entity.onBoard and target != self.entity and target.ID == self.entity.ID and "Beast" in target.race
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "A friendly Beast %s dies and %s gains +2/+1."%(target.name, self.entity.name))
		self.entity.buffDebuff(2, 1)
		
		
class Trig_EaglehornBow(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["SecretRevealed"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return subject.ID == self.entity.ID and self.entity.onBoard
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "A friendly Secret is revealed and %s gains +1 Durability."%self.entity.name)
		self.entity.gainStat(0, 1)
		
		
class Trig_GladiatorsLongbow(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["BattleStarted", "BattleFinished"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return subject == self.entity.Game.heroes[self.entity.ID] and self.entity.onBoard
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		if signal == "BattleStarted":
			PRINT(self.entity.Game, "Before attack begins, %s gives the attacking hero Immune"%self.entity.name)
			self.entity.Game.status[self.entity.ID]["Immune"] += 1
		else:
			PRINT(self.entity.Game, "After attack finished, %s removes the Immune from the attacking hero."%self.entity.name)
			self.entity.Game.status[self.entity.ID]["Immune"] -= 1
				
				
class Trig_ManaWyrm(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["SpellPlayed"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and subject.ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "Player cast a spell and %s gains +1 Attack."%self.entity.name)
		self.entity.buffDebuff(1, 0)
		
		
class Trig_Counterspell(SecretTrigger):
	def __init__(self, entity):
		self.blank_init(entity, ["SpellOKtoCast?"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return subject.ID != self.entity.ID and subject
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "Secret Counterspell Counters player's attempt to cast spell %s"%subject.name)
		subject.pop()
		
		
class Trig_IceBarrier(SecretTrigger):
	def __init__(self, entity):
		self.blank_init(entity, ["HeroAttacksHero", "MinionAttacksHero"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0): #target here holds the actual target object
		return self.entity.ID != self.entity.Game.turn and target[0] == self.entity.Game.heroes[self.entity.ID]
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "When hero %s is attack, Secret Ice Barrier is triggered and player gains 8 Armor."%target[0].name)
		self.entity.Game.heroes[self.entity.ID].gainsArmor(8)
		
		
class Trig_MirrorEntity(SecretTrigger):
	def __init__(self, entity):
		self.blank_init(entity, ["MinionBeenPlayed"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.ID != self.entity.Game.turn and subject.ID != self.entity.ID and self.entity.Game.space(self.entity.ID) > 0 and subject.health > 0 and subject.dead == False
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "After enemy minion %s is played, Secret Mirro Entity is triggered and summons a copy of it."%subject.name)
		Copy = subject.selfCopy(self.entity.ID)
		self.entity.Game.summon(Copy, -1, self.entity.ID)
		
		
class Trig_Spellbender(SecretTrigger):
	def __init__(self, entity):
		self.blank_init(entity, ["SpellTargetDecision"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.ID != self.entity.Game.turn and subject.ID != self.entity.ID and target[0] and self.entity.Game.space(self.entity.ID) > 0
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "When enemy cast spell %s on a minion, Secret Spellbender summons a 1/3 as the new target."%subject.name)
		spellbender = Spellbender_Minion(self.entity.Game, self.entity.ID)
		self.entity.Game.summon(spellbender, -1, self.entity.ID)
		target[0] = spellbender
		
class Trig_Vaporize(SecretTrigger):
	def __init__(self, entity):
		self.blank_init(entity, ["MinionAttacksHero"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0): #target here holds the target object for the attack.
		return self.entity.ID != self.entity.Game.turn and target[0] == self.entity.Game.heroes[self.entity.ID] and subject.type == "Minion" and subject.health > 0 and subject.dead == False
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "When minion %s attacks player, Secret Vaporize is triggered and destroys it"%subject.name)
		self.entity.Game.killMinion(self.entity, subject)
		
		
class Trig_EtherealArcanist(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["TurnEnds"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and ID == self.entity.ID and self.entity.Game.Secrets.secrets[self.entity.ID] != []
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "At the end of turn, player controls a Secret and %s gain +2/+2."%self.entity.name)
		self.entity.buffDebuff(2, 2)
		
		
class Trig_ArchmageAntonidas(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["SpellPlayed"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and subject.ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "Player cast a spell and %s add a 'Fireball' spell to player's hand."%self.entity.name)
		self.entity.Game.Hand_Deck.addCardtoHand(Fireball, self.entity.ID, "type")
		
class Trig_BlessingofWisdom(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["MinionAttackingHero", "MinionAttackingMinion"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and subject == self.entity
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "Minion %s attacks and Blessing of Wisdom lets its owner draw a card."%self.entity.name)
		self.entity.Game.Hand_Deck.drawCard(self.entity.ID)
		
		
class Trig_EyeforanEye(SecretTrigger):
	def __init__(self, entity):
		self.blank_init(entity, ["HeroTakesDmg"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.ID != self.entity.Game.turn and target.ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		damage = (number + self.entity.countSpellDamage()) * (2 ** self.entity.countDamageDouble())
		PRINT(self.entity.Game, "When player takes %d damage, Secret Eye for an Eye is triggered and deals %d damage to the enemy hero."%(number, damage))
		self.entity.dealsDamage(self.entity.Game.heroes[3-self.entity.ID], damage)
		
		
class Trig_NobleSacrifice(SecretTrigger):
	def __init__(self, entity):
		self.blank_init(entity, ["MinionAttacksHero", "MinionAttacksMinion", "HeroAttacksHero", "HeroAttacksMinion"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.ID != self.entity.Game.turn and subject.ID != self.entity.ID and self.entity.Game.space(self.entity.ID) > 0
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "When enemy minion %s attacks, Secret Noble Sacrifice triggers and summons a 2/1 Defender as new target."%subject.name)
		newTarget = Defender(self.entity.Game, self.entity.ID)
		self.entity.Game.summon(newTarget, -1, self.entity.ID)
		target[1] = newTarget
		
		
class Trig_Redemption(SecretTrigger):
	def __init__(self, entity):
		self.blank_init(entity, ["MinionDies"])
		self.triggered = False
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.ID != self.entity.Game.turn and target.ID == self.entity.ID and self.entity.Game.space(self.entity.ID) > 0 and not self.triggered
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "When friendly minion %s dies, Secret Redemption returns it to life with 1 Health."%target.name)
		self.triggered = True
		minion = type(target)(self.entity.Game, self.entity.ID)
		minion.health = 1
		self.entity.Game.summon(minion, -1, self.entity.ID)
		
	def createCopy(self, game):
		if self not in game.copiedObjs: #这个扳机没有被复制过
			entityCopy = self.entity.createCopy(game)
			trigCopy = self.selfCopy(entityCopy)
			trigCopy.triggered = self.triggered
			game.copiedObjs[self] = trigCopy
			return trigCopy
		else: #一个扳机被复制过了，则其携带者也被复制过了
			return game.copiedObjs[self]
			
			
class Trig_Repentance(SecretTrigger):
	def __init__(self, entity):
		self.blank_init(entity, ["MinionBeenPlayed"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.ID != self.entity.Game.turn and subject.ID != self.entity
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "After enemy minion %s is played, Secret Repentance is triggered and reduces its Health to 1."%subject.name)
		subject.statReset(False, 1)
		
		
class Trig_SwordofJustice(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["MinionBeenSummoned"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		#Can only buff if there is still durability left
		return subject.ID == self.entity.ID and self.entity.onBoard and self.entity.durability > 0
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "A friendly minion %s is summoned and %s gives it +1/+1 and loses 1 Durability."%(subject.name, self.entity.name))
		subject.buffDebuff(1, 1)
		self.entity.loseDurability()
		
		
class Trig_Lightwell(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["TurnStarts"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		curGame = self.entity.Game
		if curGame.mode == 0:
			char = None
			if curGame.guides:
				i, where = curGame.guides.pop(0)
				if where: char = curGame.find(i, where)
			else:
				chars = [char for char in curGame.charsAlive(self.entity.ID) if char.health < char.health_max]
				if chars:
					char = npchoice(chars)
					curGame.fixedGuides.append((char.position, char.type+str(char.ID)))
				else:
					curGame.fixedGuides.append((0, ''))
			if char:
				heal = 3 * (2 ** self.entity.countHealDouble())
				PRINT(curGame, "At the start of turn, Lightwell restores %d health to damaged friendly character %s"%(heal, char.name))
				self.entity.restoresHealth(char, heal)
				
				
class Trig_HeadCrack(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["TurnStarts"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "At the start of turn, Headcrack is added to players hand.")
		self.entity.Game.Hand_Deck.addCardtoHand(Headcrack, self.entity.ID, "type")
		self.disconnect()
		
		
class Trig_ManaTideTotem(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["TurnEnds"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "At the end of turn, Mana Tide Totem lets player draw a card.")
		self.entity.Game.Hand_Deck.drawCard(self.entity.ID)
		
		
class Trig_UnboundElemental(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["MinionPlayed", "SpellPlayed", "WeaponPlayed", "HeroCardPlayed"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and subject.ID == self.entity.ID and subject.overload > 0
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "Player plays a card %s with Overload and %s gains +1/+1."%(subject.name, self.entity.name))
		self.entity.buffDebuff(1, 1)
		
		
class Trig_BloodImp(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["TurnEnds"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		curGame = self.entity.Game
		if curGame.mode == 0:
			if curGame.guides:
				i = curGame.guides.pop(0)
			else:
				minions = curGame.minionsonBoard(self.entity.ID)
				try: minions.remove(self.entity)
				except: pass
				i = npchoice(minions).position if minions else -1
				curGame.fixedGuides.append(i)
			if i > -1:
				minion = curGame.minions[self.entity.ID][i]
				PRINT(curGame, "At the end of turn, Blood Imp gvies another random friendly minion %s +1 Health."%minion.name)
				minion.buffDebuff(0, 1)
				
				
class Trig_Armorsmith(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["MinionTakesDmg"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and target.ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "Friendly minion %s takes damage and %s lets player gain 1 Armor."%(target.name, self.entity.name))
		self.entity.Game.heroes[self.entity.ID].gainsArmor(1)
		
		
class Trig_FrothingBerserker(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["MinionTakesDmg"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "Minion %s takes damage and %s gains +1 Attack."%(target.name, self.entity.name))
		self.entity.buffDebuff(1, 0)
		
		
class Trig_Gorehowl(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["HeroAttackingMinion"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return subject == self.entity.Game.heroes[self.entity.ID] and target.type == "Minion" and self.entity.onBoard
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "Player's weapon Gorehowl won't lose Durability when attacking minion.")
		self.entity.canLoseDurability = False
		
		
Inspecting Shadows.py
class Trig_MagicCarpet(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["MinionBeenPlayed"])
	#The number here is the mana used to play the minion
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and subject != self.entity and subject.ID == self.entity.ID and number == 1
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "A 1-Cost friendly minion %s is played and %s gives it +1 Attack and Rush."%(subject.name, self.entity.name))
		subject.getsKeyword("Rush")
		subject.buffDebuff(1, 0)
		
		
class Trig_ArchmageVargoth(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["TurnEnds"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		curGame = self.entity.Game
		if curGame.mode == 0:
			PRINT(curGame, "At the end of turn, Archmage Vargoth casts a spell cast by player this turn")
			if curGame.guides:
				spell = curGame.guides.pop(0)
			else:
				spells = [curGame.cardPool[index] for index in curGame.Counters.cardsPlayedThisTurn[self.entity.ID]["Indices"] if "~Spell~" in index]
				spell = npchoice(spells) if spells else None
				curGame.fixedGuides.append(spell)
			if spell: spell(curGame, self.entity.ID).cast()
			
			
class Trig_ProudDefender(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["MinionAppears", "MinionDisappears"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		if signal == "MinionAppears": return self.entity.onBoard and subject.ID == self.entity.ID and subject != self.entity
		else: return self.entity.onBoard and target.ID == self.entity.ID and target != self.entity
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "%s checks board due to board change."%self.entity.name)
		self.entity.checkBoard()
		
		
class Trig_SoldierofFortune(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["MinionAttackingMinion", "MinionAttackingHero"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and subject == self.entity
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "Whenever it attacks, %s gives opponent a Coin."%self.entity.name)
		self.entity.Game.Hand_Deck.addCardtoHand(TheCoin(self.entity.Game, 3-self.entity.ID), 3-self.entity.ID)
		
		
class Trig_AzeriteElemental(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["TurnStarts"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "At the start of turn, %s gains Spell Damage +2"%self.entity.name)
		self.entity.getsKeyword("Spell Damage")
		self.entity.getsKeyword("Spell Damage")
		
		
class Trig_ExoticMountseller(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["SpellPlayed"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and subject.ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		curGame = self.entity.Game
		if curGame.mode == 0:
			if curGame.guides:
				beast = curGame.guides.pop(0)
			else:
				beast = npchoice(self.rngPool("3-Cost Beasts to Summon"])
				curGame.fixedGuides.append(beast)
			PRINT(curGame, "Player casts a spell and Exotic Mountseller summons a random 3-Cost Beast.")
			curGame.summon(beast(curGame, self.entity.ID), self.entity.position+1, self.entity.ID)
		
		
class Trig_UnderbellyOoze(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["MinionTakesDmg"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and target == self.entity and self.entity.health > 0 and self.entity.dead == False
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "%s survives damage and summon a copy of itself."%self.entity.name)
		Copy = self.entity.selfCopy(self.entity.ID)
		self.entity.Game.summon(Copy, self.entity.position+1, self.entity.ID)
		
"""Mana 8 cards"""
class Trig_Batterhead(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["MinionAttackedMinion"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and subject == self.entity and self.entity.health > 0 and self.entity.dead == False and (target.health < 1 or target.dead == True)
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "After %s attacks and kills a minion %s, it gains an extra attack chance."%(self.entity.name, target.name))
		self.entity.attChances_extra += 1
		
		
class Trig_BigBadArchmage(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["TurnEnds"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		curGame = self.entity.Game
		if curGame.mode == 0:
			if curGame.guides:
				minion = curGame.guides.pop(0)
			else:
				minion = npchoice(self.rngPool("6-Cost Minions to Summon"])
				curGame.fixedGuides.append(minion)
			PRINT(curGame, "At the end of turn, Big Bad Archmage summons a random 6-Cost minion.")
			curGame.summon(minion(curGame, self.entity.ID), self.entity.position+1, self.entity.ID)
			
"""Druid cards"""
class Trig_KeeperStalladris(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["SpellBeenPlayed"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and subject.ID == self.entity.ID and subject.chooseOne > 0
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "After player casts spell %s, %s adds copies of both choices to player's hand."%(subject.name, self.entity.name))
		for option in subject.options:
			try: self.entity.Game.Hand_Deck.addCardtoHand(option.index, self.entity.ID, "index")
			except: pass
			
			
class Trig_Lifeweaver(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["MinionGetsHealed", "HeroGetsHealed"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and subject.ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		curGame = self.entity.Game
		if curGame.mode == 0:
			PRINT(curGame, "Player restores Health and Lifeweaver adds a random Druid spell to player's hand.")
			if curGame.guides:
				spell = curGame.guides.pop(0)
			else:
				spell = npchoice(self.rngPool("Druid Spells"])
				curGame.fixedGuides.append(spell)
			curGame.Hand_Deck.addCardtoHand(spell, self.entity.ID, "type")
			
			
class Trig_SpiritofLucentbark(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["MinionGetsHealed", "HeroGetsHealed"])
		self.counter = 0
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and subject.ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "Player restores %d Health, and %s's counter records it."%(number, self.entity.name))
		self.counter += number
		if self.counter > 4:
			PRINT(self.entity.Game, "Spirit of Lucentbark transforms into Lucentbark")
			self.entity.Game.transform(self.entity, Lucentbark(self.entity.Game, self.entity.ID))
			
			
class Trig_ArcaneFletcher(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["MinionPlayed"])
	#The number here is the mana used to play the minion
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and subject != self.entity and subject.ID == self.entity.ID and number == 1
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		curGame = self.entity.Game
		if curGame.mode == 0:
			PRINT(curGame, "A 1-Cost friendly minion %s is played and Arcane Fletcher lets player draw a spell from the deck."%subject.name)
			if curGame.guides:
				i = curGame.guides.pop(0)
			else:
				spells = [i for i, card in enumerate(curGame.Hand_Deck.decks[self.entity.ID]) if card.type == "Spell"]
				i = npchoice(spells) if spells else -1
				curGame.fixedGuides.append(i)
			if i > -1: curGame.Hand_Deck.drawCard(self.entity.ID, i)
			
			
class Trig_ThoridaltheStarsFury(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["BattleFinished"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return subject == self.entity.Game.heroes[self.entity.ID] and self.entity.onBoard
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "After player attacks, Thori'dal, the Stars' Fury gives player Spell Damage +2 this turn.")
		self.entity.Game.status[self.entity.ID]["Spell Damage"] += 2
		self.entity.Game.turnEndTrigger.append(SpellDamagePlus2Disappears(self.entity.Game, self.entity.ID))
		
class Trig_MagicDartFrog(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["SpellBeenPlayed"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and subject.ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		curGame = self.entity.Game
		if curGame.mode == 0:
			PRINT(curGame, "After player casts a spell, Magic Dart Frog deals 1 damage to a random enemy minion.")
			if curGame.guides:
				i = curGame.guides.pop(0)
			else:
				minions = curGame.minionsAlive(3-self.entity.ID)
				i = npchoice(minions).position if minions else -1
				curGame.fixedGuides.append(i)
			if i > -1:
				self.entity.dealsDamage(curGame.minions[3-self.entity.ID][i], 1)
				
				
class Trig_NeverSurrender(SecretTrigger):
	def __init__(self, entity):
		self.blank_init(entity, ["SpellPlayed"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.ID != self.entity.Game.turn and subject.ID != self.entity.ID and self.entity.Game.minionsonBoard(self.entity.ID) != []
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "When the opponent casts a spell, Secret Never Surrender! is triggered and gives friendly minions +2 Health.")
		for minion in self.entity.Game.minionsonBoard(self.entity.ID):
			minion.buffDebuff(0, 2)
			
			
class Trig_Upgrade(TrigHand):
	def __init__(self, entity):
		self.blank_init(entity, ["TurnEnds"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.inHand and ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "At the end of turn, %s upgrades"%self.entity.name)
		self.entity.progress += 1
		
		
class Trig_CatrinaMuerte(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["TurnEnds"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		curGame = self.entity.Game
		if curGame.mode == 0:
			PRINT(curGame, "At the end of turn, %s summons a friendly minion that died this game."%self.entity.name)
			if curGame.guides:
				minion = curGame.guides.pop(0)
			else:
				minions = curGame.Counters.minionsDiedThisGame[self.entity.ID]
				minion = curGame.cardPool[npchoice(minions)] if minions else None
				curGame.fixedGuides.append(minion)
			if minion: curGame.summon(minion(curGame, self.entity.ID), self.entity.position+1, self.entity.ID)
			
"""Rogue cards"""
class Trig_Vendetta(TrigHand):
	def __init__(self, entity):
		self.blank_init(entity, ["CardLeavesHand", "CardEntersHand"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		#Only cards with a different class than your hero class will trigger this
		card = target[0] if signal == "CardEntersHand" else target
		return self.entity.inHand and card.ID == self.entity.ID and self.entity.Game.heroes[self.entity.ID].Class not in card.Class
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		self.entity.Game.Manas.calcMana_Single(self.entity)
		
		
class Trig_TakNozwhisker(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["CardShuffled"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		#Only triggers if the player is the initiator
		return self.entity.onBoard and ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "Player shuffles cards into deck and %s adds a copy to player's hand for each"%self.entity.name)
		if isinstance(target, (list, np.ndarray)):
			for card in target:
				if self.entity.Game.Hand_Deck.handNotFull(self.entity.ID):
					Copy = card.selfCopy(self.entity.ID)
					self.entity.Game.Hand_Deck.addCardtoHand(Copy, self.entity.ID)
				else:
					break
		else: #A single card is shuffled.
			Copy = target.selfCopy(self.entity.ID)
			self.entity.Game.Hand_Deck.addCardtoHand(Copy, self.entity.ID)
			
"""Shaman cards"""
class Trig_UnderbellyAngler(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["MinionBeenSummoned"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and subject.ID == self.entity.ID and subject != self.entity and "Murloc" in subject.race
	#Assume if Murloc gets controlled by the enemy, this won't trigger
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		curGame = self.entity.Game
		if curGame.mode == 0:
			if curGame.guides:
				murloc = curGame.guides.pop(0)
			else:
				murloc = npchoice(self.rngPool("Murlocs"])
				curGame.fixedGuides.append(murloc)
			PRINT(curGame, "After player plays Murloc %s, Underbelly Angler adds a random Murloc to player's hand."%subject.name)
			curGame.Hand_Deck.addCardtoHand(murloc, self.entity.ID, "type")
			
			
class Trig_JumboImp(TrigHand):
	def __init__(self, entity):
		self.blank_init(entity, ["MinionDies"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.inHand and target.ID == self.entity.ID and "Demon" in target.race
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		self.entity.friendlyDemonsDied += 1
		self.entity.Game.Manas.calcMana_Single(self.entity)
		
		
class Trig_FelLordBetrug(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["CardDrawn"])
		self.inherent = False
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and target[0].type == "Minion" and target[0].ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "Whenever player draws minion %s, %s summons a copy of it that has Rush and dies at the end of turn."%(target[0].name, self.entity.name))
		minion = target[0].selfCopy(self.entity.ID)
		minion.keyWords["Rush"] = 1
		minion.trigsBoard.append(Trig_DieatEndofTurn(minion))
		self.entity.Game.summon(minion, self.entity.position+1, self.entity.ID)
		
"""Warrior cards"""
class Trig_ViciousScraphound(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["MinionTakesDmg", "HeroTakesDmg"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return subject == self.entity
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "%s deals damage to %s and player gains 2 Armor."%(self.entity.name, target.name))
		self.entity.Game.heroes[self.entity.ID].gainsArmor(number)
		
		
class Trig_Wrenchcalibur(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["HeroAttackedMinion", "HeroAttackedHero"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		#The target can't be dying to trigger this
		return subject == self.entity.Game.heroes[self.entity.ID] and self.entity.onBoard
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "After hero attacks, Wrenchcalibur triggers and shuffles a Bomb in to opponent's deck")
		self.entity.Game.Hand_Deck.shuffleCardintoDeck(Bomb_Shadows(self.entity.Game, 3-self.entity.ID), self.entity.ID)
		
		
Inspecting Uldum.py
class Trig_HighkeeperRa(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["TurnEnds"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "At the end of turn, %s deals 20 damage to all enemies."%self.entity.name)
		targets = [self.entity.Game.heroes[3-self.entity.ID]] + self.entity.Game.minionsonBoard(3-self.entity.ID)
		self.entity.dealsAOE(targets, [20 for obj in targets])
		
		
class Trig_DwarvenArchaeologist(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["PutinHandbyDiscover"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		#不知道被发现的牌如果来自对手，是否会享受减费。如Griftah
		return self.entity.onBoard and ID == self.entity.ID and target.ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "A card %s is Discovered and put into player's hand, it now costs (1) less."%target.name)
		ManaMod(target, changeby=-1, changeto=-1).applies()
		self.entity.Game.Manas.calcMana_Single(target)
		
		
class Trig_SpittingCamel(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["TurnEnds"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		curGame = self.entity.Game
		if curGame.mode == 0:
			if curGame.guides:
				i = curGame.guides.pop(0)
			else:
				minions = curGame.minionsAlive(self.entity.ID, self.entity)
				i = npchoice(minions).position if minions else -1
				curGame.fixedGuides.append(-1)
			if i > -1: self.entity.dealsDamage(curGame.minions[self.entity.ID][i], 1)
			
			
class Trig_HistoryBuff(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["MinionPlayed"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and subject.ID == self.entity.ID and subject != self.entity
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		curGame = self.entity.Game
		if curGame.mode == 0:
			PRINT(curGame, "Player plays a minion and History Buff gives a random minion in hand +1/+1")
			if curGame.guides:
				i = curGame.guides.pop(0)
			else:
				minions = [i for i, card in enumerate(curGame.Hand_Deck.hands[self.entity.ID]) if card.type == "Minion"]
				i = npchoice(minions) if minions else -1
				curGame.fixedGuides.append(i)
			if i > -1: curGame.Hand_Deck.hands[self.entity.ID][i].buffDebuff(1, 1)
			
			
class Trig_ConjuredMirage(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["TurnStarts"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "At the start of turn, %s shuffles itself into player's deck"%self.entity.name)
		#随从在可以触发回合开始扳机的时机一定是不结算其亡语的。可以安全地注销其死亡扳机
		self.entity.Game.returnMiniontoDeck(self.entity, self.entity.ID, self.entity.ID, deathrattlesStayArmed=False)
		
		
class Trig_SunstruckHenchman(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["TurnStarts", "TurnEnds"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		if signal == "TurnStarts":
			curGame = self.entity.Game
			if curGame.mode == 0:
				if curGame.guides:
					sleeps = curGame.guides.pop(0)
				else:
					sleeps = nprandint(2)
					curGame.fixedGuides.append(sleeps)
				if sleeps:
					PRINT(curGame, "At the start of turn, Sunstruck Henchman falls asleep")
					self.entity.marks["Can't Attack"] += 1
				else: PRINT(curGame, "Sunstruck Henchman stays awake")
		else: self.entity.marks["Can't Attack"] -= 1 #signal == "TurnEnds"
		
		
"""Mana 5 cards"""
class Trig_DesertObelisk(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["TurnEnds"])
		
	def checkDesertObelisk(self):
		numObelisks = 0
		for minion in self.entity.Game.minionsonBoard(self.entity.ID):
			if minion.name == "Desert Obelisk":
				numObelisks += 1
				
		return numObelisks > 2
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and ID == self.entity.ID and self.checkDesertObelisk()
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		curGame = self.entity.Game
		if curGame.mode == 0:
			enemy = None
			if curGame.guides:
				i, where = curGame.guides.pop(0)
				if where: enemy = curGame.find(i, where)
			else:
				enemies = curGame.charsAlive(3-self.entity.ID)
				if enemies:
					enemy = npchoice(enemies)
					curGame.fixedGuides.append((enemy.position, enemy.type+str(enemy.ID)))
				else:
					curGame.fixedGuides.append((0, ''))
			if enemy: self.entity.dealsDamage(enemy, 5)
			
			
class Trig_MortuaryMachine(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["MinionBeenPlayed"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and subject.ID != self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "After the opponent plays minion %s, %s gives it Reborn"%(subject.name, self.entity.name))
		subject.getsKeyword("Reborn")
		
		
class Trig_WrappedGolem(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["TurnEnds"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "At the end of turn, %s summons a 1/1 Scarab with Taunt"%self.entity.name)
		self.entity.Game.summon(Scarab_Uldum(self.entity.Game, self.entity.ID), self.entity.position+1, self.entity.ID)
		
		
"""Mana 8 cards"""
class Trig_UntappedPotential(QuestTrigger):
	def __init__(self, entity):
		self.blank_init(entity, ["TurnEnds"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		if self.entity.Game.Manas.manas[self.entity.ID] > 0:
			self.counter += 1
			PRINT(self.entity.Game, "Player ends turn with unspent mana. Quest Untapped Potential progresses by 1. Current progress: %d"%self.counter)
			if self.counter > 3:
				PRINT(self.entity.Game, "Player ends turn with unspent mana for the 4th time and gains Reward: Orissian Tear.")
				self.disconnect()
				try: self.entity.Game.Secrets.mainQuests[self.entity.ID].remove(self.entity)
				except: pass
				OssirianTear(self.entity.Game, self.entity.ID).replaceHeroPower()
				
class Trig_CrystalMerchant(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["TurnEnds"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		if self.entity.Game.Manas.manas[self.entity.ID] > 0:
			PRINT(self.entity.Game, "Player ends turn with unspent Mana, and %s lets player draw a card"%self.entity.name)
			self.entity.Game.Hand_Deck.drawCard(self.entity.ID)
			
			
class Trig_AnubisathDefender(TrigHand):
	def __init__(self, entity):
		self.blank_init(entity, ["SpellBeenPlayed", "TurnStarts", "TurnEnds"]) #不需要预检测
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		if self.entity.inHand:
			if signal == "TurnStarts" or signal == "TurnEnds":
				return True
			else:
				return number > 4 and subject.ID == self.entity.ID
		return False
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "Player plays or turn starts/ends, Anubisath Defender resets its cost.")
		self.entity.Game.Manas.calcMana_Single(self.entity)
		
		
class Trig_UnsealtheVault(QuestTrigger):
	def __init__(self, entity):
		self.blank_init(entity, ["MinionBeenSummoned"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return subject.ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		self.counter += 1
		PRINT(self.entity.Game, "After player summons minion %s, Quest Unseal the Vault progresses by 1. Current progress: %d"%(subject.name, self.counter))
		if self.counter > 19:
			PRINT(self.entity.Game, "Player summons the 20th minion and gains Reward: Ramkahen Roar.")
			self.disconnect()
			try: self.entity.Game.Secrets.mainQuests[self.entity.ID].remove(self.entity)
			except: pass
			RamkahenRoar(self.entity.Game, self.entity.ID).replaceHeroPower()
			
class Trig_PressurePlate(SecretTrigger):
	def __init__(self, entity):
		self.blank_init(entity, ["SpellBeenPlayed"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.ID != self.entity.Game.turn and subject.ID != self.entity.ID and self.entity.Game.minionsAlive(3-self.entity.ID)
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		curGame = self.entity.Game
		if curGame.mode == 0:
			if curGame.guides:
				i = curGame.guides.pop(0)
			else:
				minions = curGame.minionsAlive(3-self.entity.ID)
				i = npchoice(minions).position if minions else -1
				curGame.fixedGuides.append(i)
			if i > -1: curGame.killMinion(self.entity, curGame.minions[3-self.entity.ID][i])
			
			
class Trig_DesertSpear(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["HeroAttackedMinion", "HeroAttackedHero"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		#The target can't be dying to trigger this
		return subject == self.entity.Game.heroes[self.entity.ID] and self.entity.onBoard
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "After hero attacks, weapon %s summons a 1/1 Locust with Rush"%self.entity.name)
		self.entity.Game.summon(Locust(self.entity.Game, self.entity.ID), -1, self.entity.ID)
		
		
class Trig_RaidtheSkyTemple(QuestTrigger):
	def __init__(self, entity):
		self.blank_init(entity, ["SpellPlayed"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return subject.ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		self.counter += 1
		PRINT(self.entity.Game, "Player plays spell and Quest Raid the Sky Temple progresses by 1. Current progress: %d"%self.counter)
		if self.counter > 9:
			PRINT(self.entity.Game, "Player plays the 10th spell and gains Reward: Ascendant Scroll.")
			self.disconnect()
			try: self.entity.Game.Secrets.mainQuests[self.entity.ID].remove(self.entity)
			except: pass
			AscendantScroll(self.entity.Game, self.entity.ID).replaceHeroPower()
			
class Trig_FlameWard(SecretTrigger):
	def __init__(self, entity):
		self.blank_init(entity, ["MinionAttackedHero"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.ID != self.entity.Game.turn and target == self.entity.Game.heroes[self.entity.ID]
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		damage = (3 + self.entity.countSpellDamage()) * (2 ** self.entity.countDamageDouble())
		PRINT(self.entity.Game, "After a minion attacks player, Secret Flame Ward is triggered and deals %d damage to all enemy minions."%damage)
		targets = self.entity.Game.minionsonBoard(3-self.entity.ID)
		self.entity.dealsAOE(targets, [damage for minion in targets])
		
		
class Trig_ArcaneFlakmage(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["SpellBeenPlayed"])
		
	#Assume Secretkeeper and trigger while dying.
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and subject.ID == self.entity.ID and subject.description.startswith("Secret:")
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "Player plays a Secret and %s deals 2 damage to all enemy minions"%self.entity.name)
		targets = self.entity.Game.minionsonBoard(3-self.entity.ID)
		self.entity.dealsAOE(targets, [2 for minion in targets])
		
		
class Trig_DuneSculptor(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["SpellPlayed"])
		
	#Assume Secretkeeper and trigger while dying.
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and subject.ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		curGame = self.entity.Game
		if curGame.mode == 0:
			if curGame.guides:
				minion = curGame.guides.pop(0)
			else:
				minion = npchoice(self.rngPool("Mage Minions"])
				curGame.fixedGuides.append(minion)
			PRINT(curGame, "After player casts spell, Dune Sculptor adds a random Mage minion to player's hand")
			curGame.Hand_Deck.addCardtoHand(minion, self.entity.ID, "type")
			
			
class Trig_MakingMummies(QuestTrigger):
	def __init__(self, entity):
		self.blank_init(entity, ["MinionBeenPlayed"]) #扳机是使用后扳机
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		#假设扳机的判定条件是打出的随从在检测时有复生就可以，如果在打出过程中获得复生，则依然算作任务进度
		return subject.ID == self.entity.ID and subject.keyWords["Reborn"] > 0
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		self.counter += 1
		PRINT(self.entity.Game, "Player plays Reborn minion %s and Quest Making Mummies progresses by 1. Current progress: %d"%(subject.name, self.counter))
		if self.counter > 4:
			PRINT(self.entity.Game, "Player plays the 5th spell and gains Reward: Emperor Wraps.")
			self.disconnect()
			try: self.entity.Game.Secrets.mainQuests[self.entity.ID].remove(self.entity)
			except: pass
			EmperorWraps(self.entity.Game, self.entity.ID).replaceHeroPower()
			
class Trig_BrazenZealot(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["MinionSummoned"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and subject.ID == self.entity.ID and subject != self.entity
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "A friendly minion %s is summoned and %s gains +1 attack."%(subject.name, self.entity.name))
		self.entity.buffDebuff(1, 0)
		
		
class Trig_MicroMummy(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["TurnEnds"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		curGame = self.entity.Game
		if curGame.mode == 0:
			if curGame.guides:
				i = curGame.guides.pop(0)
			else:
				minions = curGame.minionsonBoard(self.entity.ID, self.entity)
				i = npchoice(minions).position if minions else -1
				curGame.fixedGuides.append(i)
			if i > -1: curGame.minions[self.entity.ID][i].buffDebuff(1, 0)
			
			
class Trig_ActivatetheObelisk(QuestTrigger):
	def __init__(self, entity):
		self.blank_init(entity, ["MinionGetsHealed", "HeroGetsHealed"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return subject.ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		self.counter += number
		PRINT(self.entity.Game, "Player restores %d Health and Quest Activate the Obelisk progresses. Current progress: %d"%self.counter)
		if self.counter > 14:
			PRINT(self.entity.Game, "Player has restored 15 or more Health and gains Reward: Obelisk's Eye.")
			self.disconnect()
			try: self.entity.Game.Secrets.mainQuests[self.entity.ID].remove(self.entity)
			except: pass
			ObelisksEye(self.entity.Game, self.entity.ID).replaceHeroPower()
			
class Trig_SandhoofWaterbearer(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["TurnEnds"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		curGame = self.entity.Game
		if curGame.mode == 0:
			char = None
			if curGame.guides:
				i, where = curGame.guides.pop(0)
				if where: char = curGame.find(i, where)
			else:
				chars = [char for char in curGame.charsAlive(self.entity.ID) if char.health < char.health_max]
				if chars:
					char = npchoice(chars)
					curGame.fixedGuides.append((char.position, char.type+str(char.ID)))
				else:
					curGame.fixedGuides.append((0, ''))
			if char: self.entity.restoresHealth(char, 5 * (2 ** self.entity.countHealDouble()))
			
			
class Trig_HighPriestAmet(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["MinionSummoned"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and subject.ID == self.entity.ID and subject != self.entity and self.entity.health > 0
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "A friendly minion %s is summoned and %s applies its own Health on the minion."%(subject.name, self.entity.name))
		subject.statReset(False, self.entity.health)
		
		
class Trig_BazaarBurglary(QuestTrigger):
	def __init__(self, entity):
		#置入手牌扳机。抽到不同职业牌，回响牌，抽到时施放的法术都可以触发扳机。
		self.blank_init(entity, ["CardEntersHand", "SpellCastWhenDrawn"]) #抽到时施放的法术没有被处理成置入手牌
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return target[0].ID == self.entity.ID and target[0].Class != "Neutral" and self.entity.Game.heroes[self.entity.ID].Class not in target[0].Class
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		self.counter += 1
		PRINT(self.entity.Game, "A card from another Class %s is put into player's hand, Quest Bazaar Burglary progresses by 1. Current progress: %d"%(target[0].name, self.counter))
		if self.counter > 3:
			PRINT(self.entity.Game, "The 4th card from another Class is put into player's hand. Player gains Reward: Ancient Blades.")
			self.disconnect()
			try: self.entity.Game.Secrets.mainQuests[self.entity.ID].remove(self.entity)
			except: pass
			AncientBlades(self.entity.Game, self.entity.ID).replaceHeroPower()
				
class Trig_MirageBlade(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["BattleStarted", "BattleFinished"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return subject == self.entity.Game.heroes[self.entity.ID] and self.entity.onBoard
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		if signal == "BattleStarted":
			PRINT(self.entity.Game, "Before attack begins, %s gives the attacking hero Immune"%self.entity.name)
			self.entity.Game.status[self.entity.ID]["Immune"] += 1
		else:
			PRINT(self.entity.Game, "After attack finished, %s removes the Immune from the attacking hero."%self.entity.name)
			self.entity.Game.status[self.entity.ID]["Immune"] -= 1
				
				
class Trig_WhirlkickMaster(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["MinionPlayed", "SpellPlayed", "WeaponPlayed", "HeroCardPlayed"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		#这个随从本身是没有连击的。同时目前没有名字中带有Combo的牌。
		return self.entity.onBoard and subject.ID == self.entity.ID and "~Combo" in subject.index
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		curGame = self.entity.Game
		if curGame.mode == 0:
			PRINT(curGame, "Player plays a Combo card and Whirlkick Master adds random Combo card to player's hand.")
			if curGame.guides:
				card = curGame.guides.pop(0)
			else:
				card = npchoice(self.rngPool("Combo Cards"])
				curGame.fixedGuides.append(card)
			curGame.Hand_Deck.addCardtoHand(card, self.entity.ID, "type")
			
			
class Trig_CorrupttheWaters(QuestTrigger):
	def __init__(self, entity):
		self.blank_init(entity, ["MinionBeenPlayed", "WeaponBeenPlayed", "HeroCardBeenPlayed"]) #扳机是使用后扳机
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return subject.ID == self.entity.ID and "~Battlecry" in subject.index
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		self.counter += 1
		PRINT(self.entity.Game, "After player plays Battlecry card %s, Quest Corrupt the Waters progresses by 1. Current progress: %d"%(subject.name, self.counter))
		if self.counter > 5:
			PRINT(self.entity.Game, "Player plays the 6th Battlecry card and gains Reward: Heart of Vir'naal.")
			self.disconnect()
			try: self.entity.Game.Secrets.mainQuests[self.entity.ID].remove(self.entity)
			except: pass
			HeartofVirnaal(self.entity.Game, self.entity.ID).replaceHeroPower()
			
class Trig_EVILTotem(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["TurnEnds"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		curGame = self.entity.Game
		if curGame.mode == 0:
			PRINT(curGame, "At the end of turn, EVIL Totem adds a Lackey to player's hand")
			if curGame.guides:
				lackey = curGame.guides.pop(0)
			else:
				lackey = npchoice(Lackeys)
				curGame.fixedGuides.append(lackey)
			curGame.Hand_Deck.addCardtoHand(lackey, self.entity.ID, "type")
			
			
class Trig_MoguFleshshaper(TrigHand):
	def __init__(self, entity):
		self.blank_init(entity, ["MinionAppears", "MinionDisappears"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.inHand
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		self.entity.Game.Manas.calcMana_Single(self.entity)
		
		
"""Warlock cards"""
class Trig_SupremeArchaeology(QuestTrigger):
	def __init__(self, entity):
		self.blank_init(entity, ["CardDrawn"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		self.counter += 1
		PRINT(self.entity.Game, "Player draws a card. Quest Supreme Archaeologist progresses by 1. Current progress: %d"%self.counter)
		if self.counter > 19:
			PRINT(self.entity.Game, "Player draws the 20th card and gains Reward: Tome of Origination.")
			self.disconnect()
			try: self.entity.Game.Secrets.mainQuests[self.entity.ID].remove(self.entity)
			except: pass
			TomeofOrigination(self.entity.Game, self.entity.ID).replaceHeroPower()
			
class Trig_NefersetThrasher(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["MinionAttackingMinion", "MinionAttackingHero"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return subject == self.entity and self.entity.onBoard
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "Whenever it attacks, %s deals 3 damage to hero"%self.entity.name)
		self.entity.dealsDamage(self.entity.Game.heroes[self.entity.ID], 3)
		
		
class Trig_DiseasedVulture(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["HeroTookDmg"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return target == self.entity.Game.heroes[self.entity.ID] and self.entity.ID == self.entity.Game.turn
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		curGame = self.entity.Game
		if curGame.mode == 0:
			PRINT(curGame, "After player takes damage on their own turn, Diseased Vulture summons a random 3-Cost minion")
			if curGame.guides:
				minion = curGame.guides.pop(0)
			else:
				minion = npchoice(self.rngPool("3-Cost Minions to Summon"])
				curGame.fixedGuides.append(minion)
			curGame.summon(minion(curGame, self.entity.ID), self.entity.position+1, self.entity.ID)
			
			
class Trig_HacktheSystem(QuestTrigger):
	def __init__(self, entity):
		self.blank_init(entity, ["HeroAttackedHero", "HeroAttackedMinion"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return subject == self.entity.Game.heroes[self.entity.ID]
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		self.counter += 1
		PRINT(self.entity.Game, "After player attacks. Quest Hack the System progresses by 1. Current progress: %d"%self.counter)
		if self.counter > 4:
			PRINT(self.entity.Game, "Player has attacked the 5th time and gains Reward: Anraphet's Core.")
			self.disconnect()
			try: self.entity.Game.Secrets.mainQuests[self.entity.ID].remove(self.entity)
			except: pass
			AnraphetsCore(self.entity.Game, self.entity.ID).replaceHeroPower()
			
class Trig_AnraphetsCore(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["HeroAttackedHero", "HeroAttackedMinion"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return subject == self.entity.Game.heroes[self.entity.ID] and self.entity.heroPowerTimes >= self.entity.heroPowerChances_base + self.entity.heroPowerChances_extra
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "Player attacks and Hero Power Anraphet's Core is refreshed.")
		self.entity.heroPowerChances_extra += 1
		
class Trig_LivewireLance(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["HeroAttackedMinion", "HeroAttackedHero"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		#The target can't be dying to trigger this
		return subject == self.entity.Game.heroes[self.entity.ID] and self.entity.onBoard
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		curGame = self.entity.Game
		if curGame.mode == 0:
			if curGame.guides:
				lackey = curGame.guides.pop(0)
			else:
				lackey = npchoice(Lackeys)
				curGame.fixedGuides.append(lackey)
			PRINT(curGame, "After hero attacks, weapon Livewire Lance adds a Lackey to player's hand")
			curGame.Hand_Deck.addCardtoHand(lackey, self.entity.ID, "type")
			
			
class Trig_Armagedillo(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["TurnEnds"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "At the end of turn, %s gives all Taunt minions in player's hand +2/+2"%self.entity.name)
		for card in self.entity.Game.Hand_Deck.hands[self.entity.ID]:
			if card.type == "Minion" and card.keyWords["Taunt"] > 0:
				card.buffDebuff(2, 2)
				
				
class Trig_ArmoredGoon(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["HeroAttackingHero", "HeroAttackingMinion"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and subject == self.entity.Game.heroes[self.entity.ID]
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "Whenever player attacks, Armored Goon lets player gain +5 Armor")
		self.entity.Game.heroes[self.entity.ID].gainsArmor(5)
		
		
Inspecting Dragons.py
class Trig_DepthCharge(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["TurnStarts"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "At the start of turn, %s deals 5 damage to all minions"%self.entity.name)
		targets = self.entity.Game.minionsonBoard(self.entity.ID) + self.entity.Game.minionsonBoard(3-self.entity.ID)
		self.entity.dealsAOE(targets, [5 for minion in targets])
		
		
class Trig_HotAirBalloon(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["TurnStarts"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "At the start of turn, %s gains +1 Health"%self.entity.name)
		self.entity.buffDebuff(0, 1)
		
"""Mana 2 cards"""
class Trig_ParachuteBrigand(TrigHand):
	def __init__(self, entity):
		self.blank_init(entity, ["MinionBeenPlayed"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.inHand and subject.ID == self.entity.ID and "Pirate" in subject.race
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		minion = self.entity
		#不知道会召唤在最右边还是打出的海盗的右边。假设在最右边
		if minion.Game.space(minion.ID) > 0:
			PRINT(minion.Game, "After player plays Pirate, Parachute Brigand is summoned from hand")
			try: minion.Game.summonfromHand(minion.Game.Hand_Deck.hands[minion.ID].index(minion), minion.ID, -1, minion.ID)
			except: pass
			
			
class Trig_Transmogrifier(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["CardDrawn"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and target[0].ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		curGame = self.entity.Game
		if curGame.mode == 0:
			if curGame.guides:
				minion = curGame.guides.pop(0)
			else:
				minion = npchoice(self.rngPool("Legendary Minions"])
				curGame.fixedGuides.append(minion)
			PRINT(curGame, "When player draws a card %s, Transmogrifier transforms it into a random Legendary minion"%target[0].name)
			curGame.Hand_Deck.replaceCardDrawn(target, minion(curGame, self.entity.ID))
			
			
class Trig_Shuma(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["TurnEnds"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "At the end of turn, Shuma fills player's board with 1/1 Tentacles")
		self.entity.Game.summon([Tentacle_Dragons(self.entity.Game, self.entity.ID) for i in range(6)], (self.entity.position, "leftandRight"), self.entity.ID)
		
class Trig_SecuretheDeck(QuestTrigger):
	def __init__(self, entity):
		self.blank_init(entity, ["HeroAttackedHero", "HeroAttackedMinion"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return subject == self.entity.Game.heroes[self.entity.ID]
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		self.counter += 1
		PRINT(self.counter, "After player attacks. Quest Secure the Deck progresses by 1. Current progress: %d"%self.counter)
		if self.entity.progress > 1:
			PRINT(self.entity.Game, "Player has attacked twice and gain Reward: 3 'Claws'")
			self.disconnect()
			try: self.entity.Game.Secrets.sideQuests[self.entity.ID].remove(self.entity)
			except: pass
			self.entity.Game.Hand_Deck.addCardtoHand([Claw, Claw, Claw], self.entity.ID, "type")
			
			
class Trig_StrengthinNumbers(QuestTrigger):
	def __init__(self, entity): #假设人多势众是使用后扳机
		self.blank_init(entity, ["MinionBeenPlayed"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return subject.ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		curGame = self.entity.Game
		self.counter += number
		PRINT(curGame, "Player plays minion %s and Quest Strength in Numbers progresses by %d. Current progress: %d"%(subject.name, number, self.counter))
		if self.counter > 9:
			PRINT(curGame, "Player has spent at least 10 Mana on playing minions and gains Reward: Summon a minion from your deck")
			self.disconnect()
			try: self.entity.Game.Secrets.sideQuests[self.entity.ID].remove(self.entity)
			except: pass
			if curGame.mode == 0:
				if curGame.guides:
					i = curGame.guides.pop(0)
				else:
					minions = [i for i, card in enumerate(curGame.Hand_Deck.decks[self.entity.ID]) if card.type == "Minion"]
					i = npchoice(minions) if minions and curGame.space(self.entity.ID) > 0 else -1
					curGame.fixedGuides.append(i)
				if i > -1: curGame.summonfromDeck(i, self.entity.ID, -1, self.entity.ID)
				
				
class Trig_Aeroponics(TrigHand):
	def __init__(self, entity):
		self.blank_init(entity, ["MinionAppears", "MinionDisappears"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		if self.entity.inHand:
			if signal == "MinionAppears" and subject.name == "Treant":
				return True
			elif signal == "MinionDisappears" and target.name == "Treant":
				return True
		return False
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		self.entity.Game.Manas.calcMana_Single(self.entity)
		
		
class Trig_CleartheWay(QuestTrigger):
	def __init__(self, entity):
		self.blank_init(entity, ["MinionBeenSummoned"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		#不知道召唤随从因为突袭光环而具有突袭是否可以算作任务进度
		return subject.ID == self.entity.ID and subject.keyWords["Rush"] > 0
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		self.counter += 1
		PRINT(self.entity.Game, "After player summons Rush minion %s, Quest Clear the Way progresses by 1. Current progress: %d"%(subject.name, self.counter))
		if self.counter > 2:
			PRINT(self.entity.Game, "Player has summoned at least 3 Rush minions and gains Reward: Summon a 4/4 Gryphon with Rush")
			self.disconnect()
			try: self.entity.Game.Secrets.sideQuests[self.entity.ID].remove(self.entity)
			except: pass
			self.entity.Game.summon(Gryphon_Dragons(self.entity.Game, self.entity.ID), -1, self.entity.ID)
			
			
class Trig_ToxicReinforcement(QuestTrigger):
	def __init__(self, entity):
		self.blank_init(entity, ["HeroUsedAbility"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		self.counter += 1
		PRINT(self.entity.Game, "After player uses Hero Power, Quest Toxic Reinforcements progresses by 1. Current progress: %d"%self.counter)
		if self.counter > 2:
			PRINT(self.entity.Game, "Player used Hero Power for the third time and gains Reward: Summon three 1/1 Leper Gnomes")
			self.disconnect()
			try: self.entity.Game.Secrets.sideQuests[self.entity.ID].remove(self.entity)
			except: pass
			self.entity.Game.summon([LeperGnome_Dragons(self.entity.Game, self.entity.ID) for i in range(3)], (-1, "totheRightEnd"), self.entity.ID)
			
class Trig_PhaseStalker(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["HeroUsedAbility"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "After player uses Hero Power, %s puts a Secret from player's deck to battlefield"%self.entity.name)
		self.entity.Game.Secrets.deploySecretsfromDeck(self.entity.ID)
		
		
class Trig_Dragonbane(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["HeroUsedAbility"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		curGame = self.entity.Game
		if curGame.mode == 0:
			PRINT(curGame, "After player uses Hero Power, Dragonbane deals 5 damage to a random enemy")
			char = None
			if curGame.guides:
				i, where = curGame.guides.pop(0)
				if where: char = curGame.find(i, where)
			else:
				chars = curGame.charsAlive(3-self.entity.ID)
				if chars:
					char = npchoice(chars)
					curGame.fixedGuides.append((char.position, "minion%d"%char.ID) if char.type == "Minion" else (char.ID, "hero"))
				else:
					curGame.fixedGuides.append((0, ''))
			if char: self.entity.dealsDamage(char, 5)
			
			
class Trig_ElementalAllies(QuestTrigger):
	def __init__(self, entity):
		self.blank_init(entity, ["MinionBeenPlayed", "TurnEnds"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		if signal == "TurnEnds": return self.entity.ID == ID
		else: return subject.ID == self.entity.ID and "Elemental" in subject.race and self.counter < 2
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		curGame = self.entity.Game
		if signal == "TurnEnds": self.counter -= 1 * (self.counter > 0)
		else:
			self.counter += 2
			if self.counter > 2:
				PRINT(curGame, "Player has played Elementals two turns in a row and gains Reward: Draw 3 spells from your deck")
				self.disconnect()
				try: curGame.Secrets.sideQuests[self.entity.ID].remove(self.entity)
				except: pass
				ownDeck = curGame.Hand_Deck.decks[self.entity.ID]
				for num in range(3):
					if curGame.mode == 0:
						if curGame.guides:
							i = curGame.guides.pop(0)
						else:
							spells = [i for i, card in enumerate(ownDeck) if card.type == "Spell"]
							i = npchoice(spells) if spells else -1
							curGame.fixedGuides.append(i)
						if i > -1: curGame.Hand_Deck.drawCard(self.entity.ID, i)
						else: break
						
						
class Trig_LearnDraconic(QuestTrigger):
	def __init__(self, entity):
		self.blank_init(entity, ["SpellBeenPlayed"]) #假设是使用后扳机
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return subject.ID == self.entity.ID and self.entity != subject
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		self.counter += number
		PRINT(self.entity.Game, "Player spends %d Mana to to play spell, Quest Learn Draconic progresses. Current progress: %d"%(number, self.counter))
		if self.counter > 7:
			PRINT(self.entity.Game, "Player has spent 8 or more Mana on spells and gains Rewards: Summon a 6/6 Dragon")
			self.disconnect()
			try: self.entity.Game.Secrets.sideQuests[self.entity.ID].remove(self.entity)
			except: pass
			self.entity.Game.summon(DraconicEmissary(self.entity.Game, self.entity.ID), -1, self.entity.ID)
			
class Trig_Chenvaala(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["SpellBeenPlayed", "TurnEnds", "TurnStarts"])
		self.counter = 0
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		if signal == "SpellBeenPlayed":
			return self.entity.onBoard and subject.ID == self.entity.ID
		return True
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		if signal == "SpellBeenPlayed":
			self.counter += 1
			PRINT(self.entity.Game, "Player casts a spell and %s records its current progress to summon a 5/5 Elemental: %d"%(self.entity.name, self.counter))
			if self.counter > 0 and self.counter % 3 == 0:
				PRINT(self.entity.Game, "Player has cast %d spells, %s summons a 5/5 Elemental"%(self.counter, self.entity.name))
				self.entity.Game.summon(SnowElemental(self.entity.Game, self.entity.ID), self.entity.position+1, self.entity.ID)
		else: #At the start/end of turn, the counter is reset
			self.entity.resetCounter()
	#Chenvaala在游戏内复制的时候不保留扳机进度
	
class Trig_ManaGiant(TrigHand):
	def __init__(self, entity):
		#假设这个费用改变扳机在“当你使用一张法术之后”。不需要预检测
		self.blank_init(entity, ["SpellBeenPlayed"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.inHand and subject.ID == self.entity.ID and not subject.inOrigDeck
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		self.entity.Game.Manas.calcMana_Single(self.entity)
		
		
"""Paladin cards"""
class Trig_RighteousCause(QuestTrigger):
	def __init__(self, entity):
		self.blank_init(entity, ["MinionBeenSummoned"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return subject.ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		self.counter += 1
		PRINT(self.entity.Game, "After player summons minion %s, Quest Clear the Way progresses by 1. Current progress: %d"%(subject.name, self.counter))
		if self.counter > 4:
			PRINT(self.entity.Game, "Player has summoned at least 5 minions and gains Reward: Give your minions +1/+1")
			self.disconnect()
			try: self.entity.Game.Secrets.sideQuests[self.entity.ID].remove(self.entity)
			except: pass
			for minion in fixedList(self.entity.Game.minionsonBoard(self.entity.ID)):
				minion.buffDebuff(1, 1)
				
				
class Trig_Sanctuary(QuestTrigger):
	def __init__(self, entity):
		self.blank_init(entity, ["TurnStarts"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		#在我方回合开始时会触发
		return ID == self.entity.ID and self.entity.Game.Counters.dmgonHero_inOppoTurn[self.entity.ID] == 0
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "Player ends turn with without taking damage this turn and gains Reward: Summon a 4/6 with Taunt")
		self.disconnect()
		try: self.entity.Game.Secrets.sideQuests[self.entity.ID].remove(self.entity)
		except: pass
		self.entity.Game.summon(IndomitableChampion(self.entity.Game, self.entity.ID), -1, self.entity.ID)
		
class Trig_CandleBreath(TrigHand):
	def __init__(self, entity):
		self.blank_init(entity, ["CardLeavesHand", "CardEntersHand"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		#Only cards with a different class than your hero class will trigger this
		card = target[0] if signal == "CardEntersHand" else target
		return self.entity.inHand and card.ID == self.entity.ID and card.type == "Minion" and "Dragon" in card.race
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		self.entity.Game.Manas.calcMana_Single(self.entity)
		
		
class Trig_Bandersmosh_PreShifting(TrigHand):
	def __init__(self, entity):
		self.blank_init(entity, ["TurnStarts"])
		self.makesCardEvanescent = True
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.inHand and ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		curGame = self.entity.Game
		if curGame.mode == 0:
			if curGame.guides:
				minion = curGame.guides.pop(0)
			else:
				minion = npchoice(self.rngPool("Legendary Minions"])(curGame, self.entity.ID)
				curGame.fixedGuides.append(minion)
			minion = minion(curGame, self.entity.ID)
			PRINT(curGame, "At the start of turn, Bandersmosh transforms for the first time into a 5/5 copy of random Legendary minion")
			minion.statReset(5, 5)
			ManaMod(minion, changeby=0, changeto=5).applies()
			trigger = Trig_Bandersmosh_KeepShifting(minion)
			trigger.connect()
			minion.trigsBoard.append(trigger)
			curGame.Hand_Deck.replaceCardinHand(self.entity, minion)
			
class Trig_Bandersmosh_KeepShifting(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["TurnStarts"])
		self.makesCardEvanescent = True
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.inHand and ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		curGame = self.entity.Game
		if curGame.mode == 0:
			if curGame.guides:
				minion = curGame.guides.pop(0)
			else:
				minion = npchoice(self.rngPool("Legendary Minions"])(curGame, self.entity.ID)
				curGame.fixedGuides.append(minion)
			minion = minion(curGame, self.entity.ID)
			PRINT(curGame, "At the start of turn, Bandersmosh transforms for the first time into a 5/5 copy of random Legendary minion")
			minion.statReset(5, 5)
			ManaMod(minion, changeby=0, changeto=5).applies()
			trigger = Trig_Bandersmosh_KeepShifting(minion) #新的扳机保留这个变色龙的原有reference.在对方无手牌时会变回起始的变色龙。
			trigger.connect()
			minion.trigsBoard.append(trigger)
			curGame.Hand_Deck.replaceCardinHand(self.entity, minion)
			
			
class Trig_StormEgg(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["TurnStarts"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "At the start of turn, %s hatches into a 4/4 Drake with Rush"%self.entity.name)
		self.entity.Game.transform(self.entity, StormDrake(self.entity.Game, self.entity.ID))
		
class Trig_ZzerakutheWarped(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["HeroTakesDmg"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return target == self.entity.Game.heroes[self.entity.ID]
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "Player takes damage and %s summons a 6/6 Nether Drake"%self.entity.name)
		self.entity.Game.summon(NetherDrake(self.entity.Game, self.entity.ID), self.entity.position+1, self.entity.ID)
		
class Trig_Ancharrr(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["BattleFinished"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return subject == self.entity.Game.heroes[self.entity.ID] and self.entity.onBoard
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		curGame = self.entity.Game
		if curGame.mode == 0:
			PRINT(curGame, "After player attacks, Ancharrr lets player draw a Pirate from the deck")
			if curGame.guides:
				i = curGame.guides.pop(0)
			else:
				pirates = [i for i, card in enumerate(curGame.Hand_Deck.decks[self.entity.ID]) if card.type == "Minion" and "Pirate" in card.race]
				i = npchoice(pirates) if pirates else -1
				curGame.fixedGuides.append(i)
			if i > -1: curGame.Hand_Deck.drawCard(self.entity.ID, i)
			
			
class Trig_Skybarge(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["MinionBeenSummoned"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and subject.ID == self.entity.ID and "Pirate" in subject.race
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		curGame = self.entity.Game
		if curGame.mode == 0:
			PRINT(curGame, "A friendly Pirate is played and Skybarge deals 2 damage to a random enemy")
			char = None
			if curGame.guides:
				i, where = curGame.guides.pop(0)
				if where: char = curGame.find(i, where)
			else:
				chars = curGame.charsAlive(3-self.entity.ID)
				if chars:
					char = npchoice(chars)
					curGame.fixedGuides.append((char.position, "minion%d"%char.ID) if char.type == "Minion" else (char.ID, "hero"))
				else:
					curGame.fixedGuides.append((0, ''))
			if char: self.entity.dealsDamage(char, 2)
			
			
Inspecting Galakrond.py
class Trig_IceShard(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["MinionTakesDmg", "HeroTakesDmg"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return subject == self.entity
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "%s deals damage to %s and freezes it."%(self.entity.name, target.name))
		target.getsFrozen()
		
		
class Trig_FrenziedFelwing(TrigHand):
	def __init__(self, entity):
		self.blank_init(entity, ["HeroTakesDmg"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.inHand and target == self.entity.Game.heroes[3-self.entity.ID]
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		self.entity.Game.Manas.calcMana_Single(self.entity)
		
		
class Trig_EscapedManasaber(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["MinionAttackingMinion", "MinionAttackingHero"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return subject == self.entity and self.entity.onBoard
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "Whenever it attacks, %s gives player a Mana Crystal for this turn only."%self.entity.name)
		if self.entity.Game.Manas.manas[self.entity.ID] < 10:
			self.entity.Game.Manas.manas[self.entity.ID] += 1
			
			
class Trig_GrandLackeyErkh(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["MinionBeenPlayed"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and subject.ID == self.entity.ID and subject.name.endswith(" Lackey")
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		curGame = self.entity.Game
		if curGame.mode == 0:
			if curGame.guides:
				lackey = curGame.guides.pop(0)
			else:
				lackey = npchoice(Lackeys)
				curGame.fixedGuides.append(lackey)
			PRINT(curGame, "After player plays a Lackey, Grand Lackey Erkh adds a Lackey to player's hand")
			curGame.Hand_Deck.addCardtoHand(lackey, self.entity.ID, "type")
			
			
class Trig_ChopshopCopter(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["MinionDied"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and target.ID == self.entity.ID and "Mech" in target.race
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		curGame = self.entity.Game
		if curGame.mode == 0:
			if curGame.guides:
				mech = curGame.guides.pop(0)
			else:
				mech = npchoice(self.rngPool("Mechs"])
				curGame.fixedGuides.append(mech)
			PRINT(curGame, "After a friendly minion died, Chopshop Copter adds a random Mech to player's hand")
			curGame.Hand_Deck.addCardtoHand(mech, self.entity.ID, "type")
			
			
class Trig_WhatDoesThisDo(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["TurnStarts"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		curGame = self.entity.Game
		if curGame.mode == 0:
			PRINT(curGame, "At the start of turn, Hero Power What Does This Do? casts a random spell")
			if curGame.guides:
				spell = curGame.guides.pop(0)
			else:
				spell = npchoice(self.rngPool("Spells"))
				curGame.fixedGuides.append(spell)
			PRINT(curGame, "Hero Power What Does This Do? casts spell %s"%spell.name)
			spell(curGame, self.entity.ID).cast()
			
class Trig_TheFistofRaden(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["SpellBeenPlayed"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return subject.ID == self.entity.ID and self.entity.onBoard and self.entity.durability > 0
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		curGame = self.entity.Game
		if curGame.mode == 0:
			PRINT(curGame, "After player casts a spell %s, The Fist of Raden summons a random Legendary minion with that Cost and loses 1 Durability."%subject.name)
			if curGame.guides:
				minion = curGame.guides.pop(0)
			else:
				key = "%d-Cost Legendary Minions to Summon"%number
				minion = npchoice(self.rngPool(key)) if key in curGame.RNGPools and curGame.space(self.entity.ID) > 0 else None
				curGame.fixedGuides.append(minion)
			if minion:
				curGame.summon(minion(curGame, self.entity.ID), -1, self.entity.ID)
				self.entity.loseDurability()
				
				
"""Warlock cards"""
class Trig_CorruptedHand(TrigHand):
	def __init__(self, entity):
		self.blank_init(entity, ["TurnEnds"])
		self.inherent = False
		self.makesCardEvanescent = True
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		#被腐蚀的卡只会在其拥有者的回合结束时才会被丢弃
		return self.entity.inHand and self.entity.ID == ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "At the end of turn, corrupted card %s is discarded from hand."%self.entity.name)
		self.entity.Game.Hand_Deck.discardCard(self.entity.ID, self.entity)
		
		
"""Warrior cards"""
class Trig_RiskySkipper(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["MinionBeenPlayed"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and subject.ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "After player plays minion, %s deals 1 damage to all minions"%self.entity.name)
		targets = self.entity.Game.minionsonBoard(1) + self.entity.Game.minionsonBoard(2)
		self.entity.dealsAOE(targets, [1 for minion in targets])
		
	
class Trig_BombWrangler(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["MinionTakesDmg"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and target == self.entity
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "Whenever %s takes damage, it summons a 1/1 Boom Bot"%self.entity.name)
		self.entity.Game.summon(BoomBot_Dragons(self.entity.Game, self.entity.ID), self.entity.position+1, self.entity.ID)
		
Inspecting DemonHunterInitiate.py
class Trig_Battlefiend(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["HeroAttackedMinion", "HeroAttackedHero"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and subject == self.entity.Game.heroes[self.entity.ID]
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "After friendly hero attacks, %s gains +1 Attack"%self.entity.name)
		self.entity.buffDebuff(1, 0)
		
		
class Trig_AltruistheOutcast(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["MinionBeenPlayed", "SpellBeenPlayed", "WeaponBeenPlayed", "HeroCardBeenPlayed"])
		
	#The comment passed is the position of card in hand when they are played.
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and subject.ID == self.entity.ID and subject != self.entity and (comment == -1 or comment == 0)
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "After player plays the left- or right-most card in hand, %s deals 1 damage to all enemies"%self.entity.name)
		targets = [self.entity.Game.heroes[3-self.entity.ID]] + self.entity.Game.minionsonBoard(3-self.entity.ID)
		self.entity.dealsAOE(targets, [1 for enemy in targets])
		
		
class Trig_EyeBeam(TrigHand):
	def __init__(self, entity):
		self.blank_init(entity, ["CardLeavesHand", "CardEntersHand"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		if self.entity.inHand:
			card = target[0] if signal == "CardEntersHand" else target
			return card.ID == self.entity.ID
		return False
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		self.entity.Game.Manas.calcMana_Single(self.entity)
		
		
class Trig_WrathscaleNaga(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["MinionDied"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and target != self.entity and target.ID == self.entity.ID #Technically, minion has to disappear before dies. But just in case.
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		curGame = self.entity.Game
		if curGame.mode == 0:
			enemy = None
			if curGame.guides:
				i, where = curGame.guides.pop(0)
				if where: enemy = curGame.find(i, where)
			else:
				targets = curGame.charsAlive(3-self.entity.ID)
				if targets:
					enemy = npchoice(targets)
					curGame.fixedGuides.append((enemy.position, "minion%d"%enemy.ID) if enemy.type == "Minion" else (enemy.ID, "hero"))
				else: curGame.fixedGuides.append((0, ""))
			if enemy:
				PRINT(curGame, "After a friendly minion dies, Wrathscale Naga deals 3 damage to random enemy %s"%enemy.name)
				self.entity.dealsDamage(enemy, 1)
				
"""Mana 4 cards"""
class Trig_WrathspikeBrute(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["MinionAttackedMinion", "HeroAttackedMinion"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and target == self.entity
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "After %s is attacked, it deals 1 damage to all enemies."%self.entity.name)
		targets = [self.entity.Game.heroes[3-self.entity.ID]] + self.entity.Game.minionsonBoard(3-self.entity.ID)
		self.entity.dealsAOE(targets, [1 for minion in targets])
		
"""Mana 7 cards"""
class Trig_HulkingOverfiend(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["MinionAttackedMinion"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and subject == self.entity and self.entity.health > 0 and self.entity.dead == False and (target.health < 1 or target.dead == True)
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "After %s attacks and kills a minion %s, it gains an extra attack chance."%(self.entity.name, target.name))
		self.entity.attChances_extra += 1
		
		
class Trig_Nethrandamus(TrigHand):
	def __init__(self, entity):
		self.blank_init(entity, ["MinionDies"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.inHand and target.ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		self.entity.progress += 1
		
		
DemonHunterInit_Indices = {"DHInitiate~Demon Hunter~Spell~0~Blur": Blur,
							"DHInitiate~Demon Hunter~Spell~1~Twin Slice": TwinSlice,
							"DHInitiate~Demon Hunter~Spell~1~Second Slice~Uncollectible": SecondSlice,
							"DHInitiate~Demon Hunter~Minion~1~1~2~Demon~Battlefiend": Battlefiend,
							"DHInitiate~Demon Hunter~Spell~1~Consume Magic~Outcast": ConsumeMagic,
							"DHInitiate~Demon Hunter~Spell~1~Mana Burn": ManaBurn,
							"DHInitiate~Demon Hunter~Minion~1~2~1~Demon~Ur'zul Horror~Deathrattle": UrzulHorror,
							"DHInitiate~Demon Hunter~Minion~1~2~1~None~Lost Soul~Uncollectible": LostSoul,
							"DHInitiate~Demon Hunter~Spell~2~Blade Dance": BladeDance,
							"DHInitiate~Demon Hunter~Spell~2~Feast of Souls": FeastofSouls,
							"DHInitiate~Demon Hunter~Weapon~2~1~2~Umberwing~Battlecry": Umberwing,
							"DHInitiate~Demon Hunter~Minion~1~1~1~Demon~Felwing~Uncollectible": Felwing,
							"DHInitiate~Demon Hunter~Minion~4~4~2~None~Altruis the Outcast~Legendary": AltruistheOutcast,
							"DHInitiate~Demon Hunter~Spell~3~Eye Beam~Outcast": EyeBeam,
							"DHInitiate~Demon Hunter~Minion~3~3~1~None~Wrathscale Naga": WrathscaleNaga,
							"DHInitiate~Demon Hunter~Minion~4~5~3~None~Illidari Felblade~Rush~Outcast": IllidariFelblade,
							"DHInitiate~Demon Hunter~Minion~4~4~4~None~Raging Felscreamer~Battlecry": RagingFelscreamer,
							"DHInitiate~Demon Hunter~Spell~4~Soul Split": SoulSplit,
							"DHInitiate~Demon Hunter~Spell~5~Command the Illidari": CommandtheIllidari,
							"DHInitiate~Demon Hunter~Minion~5~2~6~Demon~Wrathspike Brute": WrathspikeBrute,
							"DHInitiate~Demon Hunter~Weapon~7~4~3~Flamereaper": Flamereaper,
							"DHInitiate~Demon Hunter~Minion~8~5~10~Demon~Hulking Overfiend~Rush": HulkingOverfiend,
							"DHInitiate~Demon Hunter~Minion~9~8~8~Dragon~Nethrandamus~Battlecry~Legendary": Nethrandamus,
							}
							
#The images/crops were initially in the Shadows folder. This is for batch moving the files.
#if __name__ == "__main__":
#	filename_List = []
#	for key, value in DemonHunterInit_Indices.items():
#		filename_List.append(value.__name__+".png")
#		
#	print(filename_List)Inspecting Outlands.py
class Trig_ImprisonedDormantForm(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["TurnStarts"])
		self.counter = 2
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and ID == self.entity.ID #会在我方回合开始时进行苏醒
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		self.counter -= 1
		if self.counter < 1:
			PRINT(self.entity.Game, "%s awakens and triggers its effect"%self.entity.name)
			#假设唤醒的Imprisoned Vanilla可以携带buff
			originalMinion = self.entity.originalMinion
			originalMinion.firstTimeonBoard = False
			self.entity.Game.transform(self.entity, originalMinion)
			if hasattr(originalMinion, "awakenEffect"):
				originalMinion.awakenEffect()
				
			
class Trig_InfectiousSporeling(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["MinionTookDamage"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and subject == self.entity and target.onBoard and target.health > 0 and target.dead == False
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "%s damaged minion %s and turns it into an Infectious Sporeling"%(self.entity.name, target.name))
		self.entity.Game.transform(target, InfectiousSporeling(self.entity.Game, target.ID))
		
		
class Trig_SoulboundAshtongue(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["MinionTakesDmg"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return target == self.entity
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "%s takes %d damage and deals equal amount of damage to the player"%(self.entity.name, number))
		self.entity.dealsDamage(self.entity.Game.heroes[self.entity.ID], number)
		
		
"""Mana 2 cards"""
class Trig_BonechewerBrawler(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["MinionTakesDmg"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return target == self.entity and self.entity.onBoard
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "%s takes Damage and gains +2 Attack."%self.entity.name)
		self.entity.buffDebuff(2, 0)
		
		
class Trig_MoargArtificer(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["FinalDmgonMinion?"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and target.type == "Minion" and subject.type == "Spell" and number[0] > 0
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "The %d damage dealt by spell %s on minion %s is doubled by %s"%(number[0], subject.name, target.name, self.entity.name))
		number[0] += number[0]
		
		
class Trig_BlisteringRot(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["TurnEnds"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and ID == self.entity.ID and self.entity.health > 0
	#假设召唤的Rot只是一个1/1，然后接受buff.而且该随从生命值低于1时不能触发
	#假设攻击力为负数时，召唤物的攻击力为0
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "At the start of turn, %s summons a Rot with equal stats"%self.entity.name)
		minion = LivingRot(self.entity.Game, self.entity.ID)
		if self.entity.Game.summon(minion, self.entity.position+1, self.entity.ID):
			minion.statReset(max(0, self.entity.attack), self.entity.health)
			
class Trig_Magtheridon_Dormant(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["MinionDies"]) #假设是死亡时扳机，而还是死亡后扳机
		self.counter = 0
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and type(target) == HellfireWarder and target.ID != self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		game = self.entity.Game
		PRINT(game, "A Warder summoned dies. Magtheridon awakening progress: %d"%self.counter)
		self.counter += 1
		if self.counter > 2:
			PRINT(game, "3 Warders died. Dormant Magtheridon destroys all minions and awakens")
			game.killMinion(self.entity, game.minionsonBoard(1) + game.minionsonBoard(2))
			#假设不进行强制死亡
			minion = Magtheridon(game, self.entity.ID)
			minion.firstTimeonBoard = False
			game.transform(self.entity, minion)
			
class Trig_Replicatotron(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["TurnEnds"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		minion = self.entity
		curGame = minion.Game
		if curGame.mode == 0:
			if curGame.guides:
				i = curGame.guides.pop(0)
			else:
				neighbors = self.entity.Game.neighbors2(minion)[0]
				i = npchoice(neighbors).position if neighbors else -1
				curGame.fixedGuides.append(i)
			if i > -1:
				neighbor = curGame.minions[minion.ID][i]
				PRINT(curGame, "At the start of turn, Replicat-o-tron transforms its neighbor %s into a copy of it"%neighbor.name)
				curGame.transform(neighbor, minion.selfCopy(minion.ID))
				
				
class Trig_AshesofAlar(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["TurnStarts"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "At the start of turn, %s transforms into Al'ar"%self.entity.name)
		self.entity.Game.transform(self.entity, Alar(self.entity.Game, self.entity.ID))
		
		
class Trig_KaelthasSunstrider(TrigBoard):
	def __init__(self, entity): #以我方打出一张法术之后来启动给每回合第三张法术的光环
		self.blank_init(entity, ["SpellBeenPlayed", "TurnEnds", "ManaPaid"])
		self.counter = 0
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return (signal == "TurnEnds" and self.entity.onBoard) or \
				((signal == "ManaPaid" or signal == "SpellBeenPlayed") and self.entity.onBoard and subject.type == "Spell" and subject.ID == self.entity.ID)
				
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		if signal == "TurnEnds":
			PRINT(self.entity.Game, "At the end of turn, %s shuts its Mana Aura down."%self.entity.name)
			self.entity.auras["Mana Aura"].auraDisappears()
			self.counter = 0
		elif signal == "SpellBeenPlayed":
			self.counter += 1
			if self.entity.Game.Counters.numSpellsPlayedThisTurn[self.entity.ID] % 3 == 2:
				self.entity.auras["Mana Aura"].auraAppears()
		else: #signal == "ManaPaid"
			self.entity.auras["Mana Aura"].auraDisappears()
			
			
class Trig_BonechewerVanguard(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["MinionTakesDmg"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return target == self.entity and self.entity.onBoard
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "%s takes Damage and gains +2 Attack."%self.entity.name)
		self.entity.buffDebuff(2, 0)
		
		
class Trig_DemonicBlast(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["HeroUsedAbility"])
		self.counter = 0
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return subject == self.entity
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		self.counter += 1
		PRINT(self.entity.Game, "Player uses Hero Power and Demonic Blast has been used for %d times"%self.counter)
		if self.counter > 1:
			PRINT(self.entity.Game, "Player has used Hero Power Demonic Blast twice and the Hero Power changes back to the original one it replaced")
			if self.entity.heroPowerReplaced:
				self.entity.heroPowerReplaced(self.entity.Game, self.entity.ID).replaceHeroPower()
				self.disconnect()
				
				
class Trig_WarglaivesofAzzinoth(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["HeroAttackedMinion"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return subject == self.entity.Game.heroes[self.entity.ID] and target.type == "Minion" and self.entity.onBoard
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "Player's weapon Warglaives of Azzinoth allows player to attack again after attacking minion.")
		self.entity.Game.heroes[self.entity.ID].attChances_extra +=1
		
		
class Trig_PriestessofFury(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["TurnEnds"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		curGame = self.entity.Game
		if curGame.mode == 0:
			PRINT(curGame, "At the end of turn, Priestess of Fury deals 6 damage randomly split among all enemies")
			for num in range(6):
				char = None
				if curGame.guides:
					i, where = curGame.guides.pop(0)
					if where: char = curGame.find(i, where)
				else:
					targets = curGame.charsAlive(3-self.entity.ID)
					if targets:
						char = npchoice(targets)
						curGame.fixedGuides.append((char.position, char.type+str(char.ID)))
					else:
						curGame.fixedGuides.append((0, ''))
				if char:
					PRINT(curGame, "Priestess of Fury deals 1 damage to random enemy %s"%char.name)
					self.entity.dealsDamage(char, 1)
				else: break
				
				
class Trig_PitCommander(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["TurnEnds"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		minion = self.entity
		curGame = minion.Game
		if curGame.mode == 0:
			PRINT(curGame, "At the end of turn, Pit Commander summons a Demon from player's deck")
			if curGame.guides:
				i = curGame.guides.pop(0)
			else:
				demons = [i for i, card in enumerate(curGame.Hand_Deck.decks[minion.ID]) if card.type == "Minion" and "Demon" in card.race]
				i = npchoice(demons) if demons and curGame.space(minion.ID) > 0 else -1
				curGame.fixedGuides.append(i)
			if i > -1: curGame.summonfromDeck(i, minion.ID, minion.position+1, minion.ID)
			
			
"""Druid cards"""
class Trig_Ironbark(TrigHand):
	def __init__(self, entity):
		self.blank_init(entity, ["ManaXtlsCheck"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.inHand and ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		self.entity.Game.Manas.calcMana_Single(self.entity)
		
		
class Trig_Bogbeam(TrigHand):
	def __init__(self, entity):
		self.blank_init(entity, ["ManaXtlsCheck"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.inHand and ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		self.entity.Game.Manas.calcMana_Single(self.entity)
		
		
class Trig_MarshHydra(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["MinionAttackedMinion", "MinionAttackedHero"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and subject == self.entity
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		curGame = self.entity.Game
		if curGame.mode == 0:
			if curGame.guides:
				minion = curGame.guides.pop(0)
			else:
				minion = npchoice(self.rngPool("8-Cost Minions"))
				curGame.fixedGuides.append(minion)
			PRINT(curGame, "After Marsh Hydra attacks, it adds a random 8-Cost minion into player's hand")
			curGame.Hand_Deck.addCardtoHand(minion, self.entity.ID, "type")
			
			
class Trig_PackTactics(SecretTrigger):
	def __init__(self, entity):
		self.blank_init(entity, ["MinionAttacksMinion", "HeroAttacksMinion"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.ID != self.entity.Game.turn and target[0].ID == self.entity.ID and self.entity.Game.space(self.entity.ID) > 0
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		self.entity.Game.summon(target[0].selfCopy(self.entity.ID, 3, 3), target[0].position+1, self.entity.ID)
		PRINT(self.entity.Game, "When friendly minion %s is attacked, Secret Pack Tactics triggers and summons a 3/3 Copy of it"%target[0].name)
		
		
class Trig_Evocation(TrigHand):
	def __init__(self, entity):
		self.blank_init(entity, ["TurnEnds"])
		self.inherent = False
		self.makesCardEvanescent = True
		
	#They will be discarded at the end of any turn
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.inHand
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "At the end of turn, spell %s created by Evocation is discarded"%self.entity.name)
		self.entity.Game.Hand_Deck.discardCard(self.entity.ID, self.entity)
		
		
class Trig_ApexisSmuggler(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["SpellBeenPlayed"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and subject.ID == self.entity.ID and subject.description.startswith("Secret:")
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		minion, curGame = self.entity, self.entity.Game
		if curGame.mode == 0:
			if curGame.guides:
				PRINT(curGame, "After player plays a Secret, Apexis Smuggler adds a spell to player's hand")
				curGame.Hand_Deck.addCardtoHand(curGame.guides.pop(0), minion.ID, "type", byDiscover=True)
			else:
				PRINT(curGame, "After player plays a Secret, Apexis Smuggler lets player Discover a spell")
				key = classforDiscover(minion)+" Spells"
				spells = npchoice(self.rngPool(key), 3, replace=False)
				curGame.options = [spell(curGame, minion.ID) for spell in spells]
				curGame.Discover.startDiscover(minion)
				
				
class Trig_NetherwindPortal(SecretTrigger):
	def __init__(self, entity):
		self.blank_init(entity, ["SpellBeenPlayed"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.ID != self.entity.Game.turn and subject.ID != self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		curGame = self.entity.Game
		if curGame.mode == 0:
			if curGame.guides:
				minion = curGame.guides.pop(0)
			else:
				minion = npchoice(self.rngPool("4-Cost Minions to Summon"))
				curGame.fixedGuides.append(minion)
			PRINT(curGame, "After the opponent casts a spell, Secret Netherwind Portal is triggered and summons a random 4-Cost minion")
			curGame.summon(minion(curGame, self.entity.ID), -1, self.entity.ID)
		
		
class Trig_UnderlightAnglingRod(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["HeroAttackedMinion", "HeroAttackedHero"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return subject == self.entity.Game.heroes[self.entity.ID] and self.entity.onBoard
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		curGame = self.entity.Game
		if curGame.mode == 0:
			if curGame.guides:
				murloc = curGame.guides.pop(0)
			else:
				murloc = npchoice(self.rngPool("Murlocs"))
				curGame.fixedGuides.append(murloc)
			PRINT(curGame, "After player attacks, weapon %s adds a random Murloc to player's hand."%self.entity.name)
			curGame.Hand_Deck.addCardtoHand(murloc, self.entity.ID, "type")
			
			
class Trig_SethekkVeilweaver(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["SpellBeenPlayed"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and subject.ID == self.entity.ID and target and target.type == "Minion"
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		curGame = self.entity.Game
		if curGame.mode == 0:
			if curGame.guides:
				spell = curGame.guides.pop(0)
			else:
				spell = npchoice(self.rngPool("Priest Spells"))
				curGame.fixedGuides.append(spell)
			PRINT(curGame, "After player casts spell %s on minion %s, Sethekk Veilweaver adds a random Priest spell to player's hand"%(subject.name, target.name))
			curGame.Hand_Deck.addCardtoHand(spell, self.entity.ID, "type")
			
			
class Trig_DragonmawOverseer(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["TurnEnds"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		curGame = self.entity.Game
		if curGame.mode == 0:
			if curGame.guides:
				i = curGame.guides.pop(0)
			else:
				minions = curGame.minionsonBoard(self.entity.ID)
				try: minions.remove(self.entity)
				except: pass
				i = npchoice(minions).position if minions else -1
				curGame.fixedGuides.append(i)
			if i > -1:
				minion = curGame.minions[self.entity.ID][i]
				PRINT(curGame, "At the end of turn, Dragonmaw Overseer gvies another random friendly minion %s +2/+2."%minion.name)
				minion.buffDebuff(2, 2)
				
				
class Trig_SkeletalDragon(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["TurnEnds"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		curGame = self.entity.Game
		if curGame.mode == 0:
			if curGame.guides:
				dragon = curGame.guides.pop(0)
			else:
				dragon = npchoice(self.rngPool("Dragons"))
				curGame.fixedGuides.append(dragon)
			PRINT(curGame, "At the end of turn, Skeletal Dragon adds a random Dragon to player's hand")
			curGame.Hand_Deck.addCardtoHand(dragon, self.entity.ID, "type")
			
			
class Trig_Ambush(SecretTrigger):
	def __init__(self, entity):
		self.blank_init(entity, ["MinionBeenPlayed"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.ID != self.entity.Game.turn and subject.ID != self.entity.ID and self.entity.Game.space(self.entity.ID) > 0
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "After enemy minion %s is played, Secret Ambush is triggered and summons a 2/3 Ambusher with Poisonous."%subject.name)
		self.entity.Game.summon(BrokenAmbusher(self.entity.Game, self.entity.ID), -1, self.entity.ID)
		
class Trig_Bamboozle(SecretTrigger):
	def __init__(self, entity):
		self.blank_init(entity, ["MinionAttacksMinion", "HeroAttacksMinion"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.ID != self.entity.Game.turn and target[0].ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		curGame = self.entity.Game
		if curGame.mode == 0:
			if curGame.guides:
				newMinion = curGame.guides.pop(0)
			else:
				cost = type(target[0]).mana + 3
				while cost not in curGame.MinionsofCost:
					cost -= 1
				newMinion = npchoice(self.rngPool("%d-Cost Minions to Summon"%cost))
				curGame.fixedGuides.append(newMinion)
			PRINT(curGame, "When friendly minion %s is attacked, Secret Bamboozle triggers and transforms it into a random one that costs (3) more"%target[0].name)
			#不知道如果攻击目标已经被导离这个目标随从之后是否会把目标重导向回它，假设不会
			newMinion = newMinion(curGame, self.entity.ID)
			curGame.transform(target[0], newMinion)
			if target[0] == target[1]: target[0], target[1] = newMinion, newMinion
			else: target[0] = newMinion
			
			
class Trig_DirtyTricks(SecretTrigger):
	def __init__(self, entity):
		self.blank_init(entity, ["SpellBeenPlayed"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.ID != self.entity.Game.turn and subject.ID != self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "After the opponent casts a spell, Secret Dirty Tricks is triggered and lets player draw 2 cards")
		self.entity.Game.Hand_Deck.drawCard(self.entity.ID)
		self.entity.Game.Hand_Deck.drawCard(self.entity.ID)
		
		
class Trig_ShadowjewelerHanar(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["SpellBeenPlayed"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and subject.ID == self.entity.ID and subject.description.startswith("Secret:")
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		minion, curGame = self.entity, self.entity.Game
		if minion.ID == curGame.turn:
			if curGame.mode == 0:
				if curGame.guides:
					PRINT(curGame, "After player plays a Secret, Shadowjeweler Hanar adds a Secret from a different class to player's hand")
					curGame.Hand_Deck.addCardtoHand(curGame.guides.pop(0), minion.ID, "type")
				else:
					PRINT(curGame, "After player plays a Secret, Shadowjeweler Hanar lets player Discover a Secret from a different class")
					ClasseswithSecrets = ["Hunter", "Mage", "Paladin", "Rogue"]
					try: ClasseswithSecrets.remove(subject.Class)
					except: pass
					Classes = npchoice(ClasseswithSecrets, 3, replace=False)
					secrets = [npchoice(self.rngPool(Class+" Secrets")) for Class in Classes]
					curGame.options = [secret(curGame, minion.ID) for secret in secrets]
					curGame.Discover.startDiscover(minion)
					
					
class Trig_BoggspineKnuckles(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["HeroAttackedMinion", "HeroAttackedHero"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return subject == self.entity.Game.heroes[self.entity.ID] and self.entity.onBoard
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		curGame = self.entity.Game
		PRINT(curGame, "After player attacks, weapon Boggspine Knuckles transforms friendly minions into ones that cost (1) more.")
		if curGame.mode == 0:
			for minion in curGame.minionsonBoard(self.entity.ID):
				if curGame.guides:
					newMinion = curGame.guides.pop(0)
				else:
					cost = type(minion).mana + 1
					while cost not in curGame.MinionsofCost:
						cost -= 1
					newMinion = npchoice(self.rngPool("%d-Cost Minions to Summon"%cost))
					curGame.fixedGuides.append(newMinion)
				curGame.transform(minion, newMinion(curGame, minion.ID))
				
				
class Trig_Darkglare(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["HeroTookDmg"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return target == self.entity.Game.heroes[self.entity.ID]
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "After player takes damage, Darkglare refreshes 2 of player's Mana Crystals")
		self.entity.Game.Manas.restoreManaCrystal(1, self.entity.ID)
		
		
class Trig_KelidantheBreaker(TrigHand):
	def __init__(self, entity):
		self.blank_init(entity, ["TurnEnds"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.inHand and self.entity.justDrawn and ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		self.entity.justDrawn = False
		self.disconnect() #只需要触发一次
		
		
class Trig_BulwarkofAzzinoth(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["FinalDmgonHero?"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		#Can only prevent damage if there is still durability left
		return target == self.entity.Game.heroes[self.entity.ID] and self.entity.onBoard and self.entity.durability > 0
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "Player is about to take damage and %s prevents it at the cost of losing 1 Durability."%self.entity.name)
		number[0] = 0
		self.entity.loseDurability()
		
		
class Trig_KargathPrime(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["MinionAttackedMinion"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return subject == self.entity and self.entity.onBoard and (target.health < 1 or target.dead == True)
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "After %s attacks and kills minion %s, the player gains 10 Armor."%(self.entity.name, target.name))
		self.entity.Game.heroes[self.entity.ID].gainsArmor(10)
		
		
class Trig_BloodboilBrute(TrigHand):
	def __init__(self, entity):
		self.blank_init(entity, ["MinionAppears", "MinionDisappears", "MinionTakesDmg"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.inHand
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		self.entity.Game.Manas.calcMana_Single(self.entity)
		
		
		
		
Outlands_Indices = {"Outlands~Neutral~Minion~1~2~1~None~Ethereal Augmerchant~Battlecry": EtherealAugmerchant,
					"Outlands~Neutral~Minion~1~2~1~None~Guardian Augmerchant~Battlecry": GuardianAugmerchant,
					"Outlands~Neutral~Minion~1~1~2~None~Infectious Sporeling": InfectiousSporeling,
					"Outlands~Neutral~Minion~1~2~1~None~Rocket Augmerchant~Battlecry": RocketAugmerchant,
					"Outlands~Neutral~Minion~1~1~4~None~Soulbound Ashtongue": SoulboundAshtongue,
					"Outlands~Neutral~Minion~2~2~3~None~Bonechewer Brawler~Taunt": BonechewerBrawler,
					"Outlands~Neutral~Minion~2~3~5~Demon~Imprisoned Vilefiend~Rush": ImprisonedVilefiend,
					"Outlands~Neutral~Minion~2~2~4~Demon~Mo'arg Artificer": MoargArtificer,
					"Outlands~Neutral~Minion~2~2~2~None~Rustsworn Initiate~Deathrattle": RustswornInitiate,
					"Outlands~Neutral~Minion~1~1~1~Demon~Impcaster~Spell Damage~Uncollectible": Impcaster,
					"Outlands~Neutral~Minion~3~1~2~None~Blistering Rot": BlisteringRot,
					"Outlands~Neutral~Minion~1~1~1~None~Living Rot~Uncollectible": LivingRot,
					"Outlands~Neutral~Minion~3~4~3~None~Frozen Shadoweaver~Battlecry": FrozenShadoweaver,
					"Outlands~Neutral~Minion~3~1~6~None~Overconfident Orc~Taunt": OverconfidentOrc,
					"Outlands~Neutral~Minion~3~3~7~Demon~Terrorguard Escapee~Battlecry": TerrorguardEscapee,
					"Outlands~Neutral~Minion~1~1~1~None~Huntress~Uncollectible": Huntress,
					"Outlands~Neutral~Minion~3~3~4~None~Teron Gorefiend~Battlecry~Deathrattle~Legendary": TeronGorefiend,
					"Outlands~Neutral~Minion~4~5~2~Beast~Burrowing Scorpid~Battlecry": BurrowingScorpid,
					"Outlands~Neutral~Minion~4~3~3~Demon~Disguised Wanderer~Deathrattle": DisguisedWanderer,
					"Outlands~Neutral~Minion~4~9~1~Demon~Rustsworn Inquisitor~Uncollectible": RustswornInquisitor,
					"Outlands~Neutral~Minion~4~4~4~Murloc~Felfin Navigator~Battlecry": FelfinNavigator,
					"Outlands~Neutral~Minion~4~12~12~Demon~Magtheridon~Battlecry~Legendary": Magtheridon,
					"Outlands~Neutral~Minion~1~1~3~None~Hellfire Warder~Uncollectible": HellfireWarder,
					"Outlands~Neutral~Minion~4~4~3~None~Maiev Shadowsong~Battlecry~Legendary": MaievShadowsong,
					"Outlands~Neutral~Minion~4~3~3~Mech~Replicat-o-tron": Replicatotron,
					"Outlands~Neutral~Minion~4~3~3~None~Rustsworn Cultist~Battlecry": RustswornCultist,
					"Outlands~Neutral~Minion~1~1~1~Demon~Rusted Devil~Uncollectible": RustedDevil,
					"Outlands~Neutral~Minion~5~7~3~Elemental~Al'ar~Deathrattle~Legendary": Alar,
					"Outlands~Neutral~Minion~1~0~3~None~Ashes of Al'ar~Legendary~Uncollectible": AshesofAlar,
					"Outlands~Neutral~Minion~5~1~8~None~Ruststeed Raider~Taunt~Rush~Battlecry": RuststeedRaider,
					"Outlands~Neutral~Minion~5~3~3~None~Waste Warden~Battlecry": WasteWarden,
					"Outlands~Neutral~Minion~6~5~6~Dragon~Dragonmaw Sky Stalker~Deathrattle": DragonmawSkyStalker,
					"Outlands~Neutral~Minion~3~3~4~None~Dragonrider~Uncollectible": Dragonrider,
					"Outlands~Neutral~Minion~6~6~3~Demon~Scavenging Shivarra~Battlecry": ScavengingShivarra,
					"Outlands~Neutral~Minion~7~4~10~None~Bonechewer Vanguard~Taunt": BonechewerVanguard,
					"Outlands~Neutral~Minion~7~4~7~None~Kael'thas Sunstrider~Legendary": KaelthasSunstrider,
					"Outlands~Neutral~Minion~8~12~12~Demon~Supreme Abyssal": SupremeAbyssal,
					"Outlands~Neutral~Minion~10~7~7~Elemental~Scrapyard Colossus~Taunt~Deathrattle": ScrapyardColossus,
					"Outlands~Neutral~Minion~7~7~7~Elemental~Felcracked Colossus~Taunt~Uncollectible": FelcrackedColossus,
					"Outlands~Demon Hunter~Minion~1~1~1~None~Crimson Sigil Runner~Outcast": CrimsonSigilRunner,
					"Outlands~Demon Hunter~Minion~2~3~2~Murloc~Furious Felfin~Battlecry": FuriousFelfin,
					"Outlands~Demon Hunter~Spell~2~Immolation Aura": ImmolationAura,
					"Outlands~Demon Hunter~Minion~2~2~2~None~Netherwalker~Battlecry": Netherwalker,
					"Outlands~Demon Hunter~Spell~2~Spectral Sight~Outcast": SpectralSight,
					"Outlands~Demon Hunter~Minion~4~3~5~None~Ashtongue Battlelord~Taunt~Lifesteal": AshtongueBattlelord,
					"Outlands~Demon Hunter~Minion~6~8~3~None~Fel Summoner~Deathrattle": FelSummoner,
					"Outlands~Demon Hunter~Minion~4~3~4~None~Kayn Sunfury~Charge~Legendary": KaynSunfury,
					"Outlands~Demon Hunter~Spell~5~Metamorphosis~Legendary": Metamorphosis,
					"Outlands~Demon Hunter~Weapon~6~3~4~Warglaives of Azzinoth": WarglaivesofAzzinoth,
					"Outlands~Demon Hunter~Minion~6~10~6~Demon~Imprisoned Antaen": ImprisonedAntaen,
					"Outlands~Demon Hunter~Spell~6~Skull of Gul'dan~Outcast": SkullofGuldan,
					"Outlands~Demon Hunter~Minion~7~6~5~Demon~Priestess of Fury": PriestessofFury,
					"Outlands~Demon Hunter~Minion~8~9~5~None~Coilfang Warlord~Rush~Deathrattle": CoilfangWarlord,
					"Outlands~Demon Hunter~Minion~8~5~9~None~Conchguard Warlord~Taunt~Uncollectible": ConchguardWarlord,
					"Outlands~Demon Hunter~Minion~9~7~9~Demon~Pit Commander~Taunt": PitCommander,
					"Outlands~Druid~Spell~3~Fungal Fortunes": FungalFortunes,
					"Outlands~Druid~Spell~2~Ironbark": Ironbark,
					"Outlands~Druid~Minion~3~3~4~None~Archspore Msshi'fn~Taunt~Deathrattle~Legendary": ArchsporeMsshifn,
					"Outlands~Druid~Minion~10~9~9~None~Msshi'fn Prime~Taunt~Choose One~Legendary~Uncollectible": MsshifnPrime,
					"Outlands~Druid~Minion~10~9~9~None~Fungal Guardian~Taunt~Uncollectible": FungalGuardian,
					"Outlands~Druid~Minion~10~9~9~None~Fungal Bruiser~Rush~Uncollectible": FungalBruiser,
					"Outlands~Druid~Minion~10~9~9~None~Fungal Gargantuan~Taunt~Rush~Uncollectible": FungalGargantuan,
					"Outlands~Druid~Spell~3~Bogbeam": Bogbeam,
					"Outlands~Druid~Minion~3~3~3~Demon~Imprisoned Satyr": ImprisonedSatyr,
					"Outlands~Druid~Spell~4~Germination": Germination,
					"Outlands~Druid~Spell~4~Overgrowth": Overgrowth,
					"Outlands~Druid~Spell~5~Glowfly Swarm": GlowflySwarm,
					"Outlands~Druid~Minion~2~2~2~Beast~Glowfly~Uncollectible": Glowfly,
					"Outlands~Druid~Minion~7~7~7~Beast~Marsh Hydra~Rush": MarshHydra,
					"Outlands~Druid~Minion~9~5~5~None~Ysiel Windsinger~Legendary": YsielWindsinger,
					"Outlands~Hunter~Minion~1~2~1~Beast~Helboar~Deathrattle": Helboar,
					"Outlands~Hunter~Minion~2~5~4~Demon~Imprisoned Felmaw": ImprisonedFelmaw,
					"Outlands~Hunter~Spell~2~Pack Tactics~~Secret": PackTactics,
					"Outlands~Hunter~Spell~2~Scavenger's Ingenuity": ScavengersIngenuity,
					"Outlands~Hunter~Minion~3~2~4~Beast~Augmented Porcupine~Deathrattle": AugmentedPorcupine,
					"Outlands~Hunter~Minion~3~2~4~Beast~Zixor, Apex Predator~Rush~Deathrattle~Legendary": ZixorApexPredator,
					"Outlands~Hunter~Minion~8~4~4~Beast~Zixor Prime~Rush~Battlecry~Legendary~Uncollectible": ZixorPrime,
					"Outlands~Hunter~Minion~4~5~2~Beast~Mok'Nathal Lion~Rush~Battlecry": MokNathalLion,
					"Outlands~Hunter~Spell~4~Scrap Shot": ScrapShot,
					"Outlands~Hunter~Minion~8~5~5~None~Beastmaster Leoroxx~Battlecry~Legendary": BeastmasterLeoroxx,
					"Outlands~Hunter~Spell~10~Nagrand Slam": NagrandSlam,
					"Outlands~Hunter~Minion~4~3~5~Beast~Clefthoof~Uncollectible": Clefthoof,
					"Outlands~Mage~Spell~2~Evocation~Legendary": Evocation,
					"Outlands~Mage~Spell~1~Font of Power": FontofPower,
					"Outlands~Mage~Minion~2~2~3~None~Apexis Smuggler": ApexisSmuggler,
					"Outlands~Mage~Minion~2~3~2~None~Astromancer Solarian~Spell Damage~Deathrattle~Legendary": AstromancerSolarian,
					"Outlands~Mage~Minion~9~7~7~Demon~Solarian Prime~Spell Damage~Battlecry~Legendary~Uncollectible": SolarianPrime,
					"Outlands~Mage~Spell~2~Incanter's Flow": IncantersFlow,
					"Outlands~Mage~Minion~2~3~1~None~Starscryer~Deathrattle": Starscryer,
					"Outlands~Mage~Minion~3~4~5~Demon~Imprisoned Observer": ImprisonedObserver,
					"Outlands~Mage~Spell~3~Netherwind Portal~~Secret": NetherwindPortal,
					"Outlands~Mage~Spell~5~Apexis Blast": ApexisBlast,
					"Outlands~Mage~Spell~8~Deep Freeze": DeepFreeze,
					"Outlands~Paladin~Minion~1~2~1~Murloc~Imprisoned Sungill": ImprisonedSungill,
					"Outlands~Paladin~Minion~1~1~1~Murloc~Sungill Streamrunner~Uncollectible": SungillStreamrunner,
					"Outlands~Paladin~Minion~1~1~3~None~Aldor Attendant~Battlecry": AldorAttendant,
					"Outlands~Paladin~Spell~2~Hand of A'dal": HandofAdal,
					"Outlands~Paladin~Minion~2~2~1~Murloc~Murgur Murgurgle~Divine Shield~Deathrattle~Legendary": MurgurMurgurgle,
					"Outlands~Paladin~Minion~8~6~3~Murloc~Murgurgle Prime~Divine Shield~Battlecry~Legendary~Uncollectible": MurgurglePrime,
					"Outlands~Paladin~Spell~2~Libram of Wisdom": LibramofWisdom,
					"Outlands~Paladin~Weapon~3~3~2~Underlight Angling Rod": UnderlightAnglingRod,
					"Outlands~Paladin~Minion~5~4~6~None~Aldor Truthseeker~Battlecry": AldorTruthseeker,
					"Outlands~Paladin~Spell~5~Libram of Justice": LibramofJustice,
					"Outlands~Paladin~Weapon~1~1~4~Overdue Justice~Uncollectible": OverdueJustice,
					"Outlands~Paladin~Minion~7~4~6~None~Lady Liadrin~Battlecry~Legendary": LadyLiadrin,
					"Outlands~Paladin~Spell~9~Libram of Hope": LibramofHope,
					"Outlands~Paladin~Minion~8~8~8~None~Ancient Guardian~Taunt~Divine Shield~Uncollectible": AncientGuardian,
					"Outlands~Priest~Minion~1~2~5~Demon~Imprisoned Homunculus~Taunt": ImprisonedHomunculus,
					"Outlands~Priest~Minion~1~1~3~None~Reliquary of Souls~Lifesteal~Deathrattle~Legendary": ReliquaryofSouls,
					"Outlands~Priest~Minion~7~6~8~None~Reliquary Prime~Taunt~Lifesteal~Legendary~Uncollectible": ReliquaryPrime,
					"Outlands~Priest~Spell~1~Renew": Renew,
					"Outlands~Priest~Minion~2~1~4~None~Dragonmaw Sentinel~Battlecry": DragonmawSentinel,
					"Outlands~Priest~Minion~2~2~3~None~Sethekk Veilweaver": SethekkVeilweaver,
					"Outlands~Priest~Spell~3~Apotheosis": Apotheosis,
					"Outlands~Priest~Minion~3~2~2~None~Dragonmaw Overseer": DragonmawOverseer,
					"Outlands~Priest~Spell~5~Psyche Split": PsycheSplit,
					"Outlands~Priest~Minion~7~4~9~Dragon~Skeletal Dragon~Taunt": SkeletalDragon,
					"Outlands~Priest~Spell~7~Soul Mirror~Legendary": SoulMirror,
					"Outlands~Rogue~Minion~1~1~2~None~Blackjack Stunner~Battlecry": BlackjackStunner,
					"Outlands~Rogue~Minion~1~3~1~None~Spymistress~Stealth": Spymistress,
					"Outlands~Rogue~Spell~2~Ambush~~Secret": Ambush,
					"Outlands~Rogue~Minion~2~2~3~None~Broken Ambusher~Poisonous~Uncollectible": BrokenAmbusher,
					"Outlands~Rogue~Minion~2~3~2~None~Ashtongue Slayer~Battlecry": AshtongueSlayer,
					"Outlands~Rogue~Spell~2~Bamboozle~~Secret": Bamboozle,
					"Outlands~Rogue~Spell~2~Dirty Tricks~~Secret": DirtyTricks,
					"Outlands~Rogue~Minion~2~1~4~None~Shadowjeweler Hanar~Legendary": ShadowjewelerHanar,
					"Outlands~Rogue~Minion~3~3~4~None~Akama~Stealth~Deathrattle~Legendary": Akama,
					"Outlands~Rogue~Minion~6~6~5~None~Akama Prime~Stealth~Legendary~Uncollectible": AkamaPrime,
					"Outlands~Rogue~Minion~3~3~3~None~Greyheart Sage~Battlecry": GreyheartSage,
					"Outlands~Rogue~Minion~7~7~5~None~Cursed Vagrant~Deathrattle": CursedVagrant,
					"Outlands~Rogue~Minion~7~7~5~None~Cursed Shadow~Stealth~Uncollectible": CursedShadow,
					"Outlands~Shaman~Minion~3~3~3~None~Bogstrok Clacker~Battlecry": BogstrokClacker,
					"Outlands~Shaman~Minion~3~4~3~None~Lady Vashj~Spell Damage~Deathrattle~Legendary": LadyVashj,
					"Outlands~Shaman~Minion~7~5~4~None~Vashj Prime~Spell Damage~Battlecry~Legendary~Uncollectible": VashjPrime,
					"Outlands~Shaman~Minion~3~3~4~Elemental~Marshspawn~Battlecry": Marshspawn,
					"Outlands~Shaman~Spell~3~Serpentshrine Portal~Overload": SerpentshrinePortal,
					"Outlands~Shaman~Spell~3~Totemic Reflection": TotemicReflection,
					"Outlands~Shaman~Spell~4~Vivid Spores": VividSpores,
					"Outlands~Shaman~Weapon~5~4~2~Boggspine Knuckles": BoggspineKnuckles,
					"Outlands~Shaman~Minion~5~5~6~Elemental~Shattered Rumbler~Battlecry": ShatteredRumbler,
					"Outlands~Shaman~Spell~4~Torrent": Torrent,
					"Outlands~Shaman~Minion~6~6~5~Beast~The Lurker Below~Battlecry~Legendary": TheLurkerBelow,
					"Outlands~Warlock~Spell~1~Shadow Council": ShadowCouncil,
					"Outlands~Warlock~Spell~1~Unstable Felbolt": UnstableFelbolt,
					"Outlands~Warlock~Minion~2~3~3~Demon~Imprisoned Scrap Imp": ImprisonedScrapImp,
					"Outlands~Warlock~Minion~2~3~2~None~Kanrethad Ebonlocke~Deathrattle~Legendary": KanrethadEbonlocke,
					"Outlands~Warlock~Minion~8~7~6~Demon~Kanrethad Prime~Battlecry~Legendary~Uncollectible": KanrethadPrime,
					"Outlands~Warlock~Minion~2~2~3~Demon~Darkglare": Darkglare,
					"Outlands~Warlock~Minion~4~5~5~Demon~Nightshade Matron~Rush~Battlecry": NightshadeMatron,
					"Outlands~Warlock~Spell~4~The Dark Portal": TheDarkPortal,
					"Outlands~Warlock~Spell~6~Hand of Gul'dan": HandofGuldan,
					"Outlands~Warlock~Minion~6~3~3~None~Keli'dan the Breaker~Battlecry~Legendary": KelidantheBreaker,
					"Outlands~Warlock~Minion~8~5~7~Demon~Enhanced Dreadlord~Taunt~Deathrattle": EnhancedDreadlord,
					"Outlands~Warlock~Minion~5~5~5~Demon~Desperate Dreadlord~Lifesteal~Uncollectible": DesperateDreadlord,
					"Outlands~Warrior~Minion~1~2~2~Demon~Imprisoned Gan'arg": ImprisonedGanarg,
					"Outlands~Warrior~Spell~1~Sword and Board": SwordandBoard,
					"Outlands~Warrior~Spell~2~Corsair Cache": CorsairCache,
					"Outlands~Warrior~Spell~3~Bladestorm": Bladestorm,
					"Outlands~Warrior~Minion~3~3~3~None~Bonechewer Raider~Battlecry": BonechewerRaider,
					"Outlands~Warrior~Weapon~3~1~4~Bulwark of Azzinoth~Legendary": BulwarkofAzzinoth,
					"Outlands~Warrior~Minion~3~1~10~None~Warmaul Challenger~Battlecry": WarmaulChallenger,
					"Outlands~Warrior~Minion~4~4~4~None~Kargath Bladefist~Rush~Deathrattle~Legendary": KargathBladefist,
					"Outlands~Warrior~Minion~8~10~10~None~Kargath Prime~Rush~Legendary~Uncollectible": KargathPrime,
					"Outlands~Warrior~Minion~5~4~5~Mech~Scrap Golem~Taunt~Deathrattle": ScrapGolem,
					"Outlands~Warrior~Minion~7~5~8~None~Bloodboil Brute~Rush": BloodboilBrute,
					}Inspecting Academy.py
class Trig_IntrepidInitiate(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["SpellBeenPlayed"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and subject.ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		self.disconnect()
		try: self.entity.trigsBoard.remove(self)
		except: pass
		PRINT(self.entity.Game, "After player plays a spell, Intrepid Initiate gains +2 Attack")
		self.entity.buffDebuff(2, 0)
		
		
class Trig_PenFlinger(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["SpellBeenPlayed"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and subject.ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		minion = self.entity
		self.disconnect()
		try: minion.trigsBoard.remove(self)
		except: pass
		PRINT(minion.Game, "After player plays a spell, Pen Flinger returns itself to player's hand.")
		minion.Game.returnMiniontoHand(minion, deathrattlesStayArmed=False)
		
		
class Trig_SphereofSapience(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["TurnStarts"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return ID == self.entity.ID and self.entity.onBoard and self.entity.durability > 0
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		curGame = self.entity.Game
		ownDeck = curGame.Hand_Deck.decks[self.entity.ID]
		if curGame.mode == 0:
			if curGame.guides:
				drawNewCard = curGame.guides.pop(0)
				if drawNewCard:
					PRINT(curGame, "At the start of turn, Sphere of Sapience allows player to move the top card in deck to the bottom")
					ownDeck.insert(0, ownDeck.pop())
					self.entity.loseDurability()
			else:
				if curGame.Hand_Deck.decks[self.entity.ID]:
					curGame.options = [ownDeck[-1], NewFate()]
					curGame.Discover.startDiscover(self.entity)
				else: curGame.fixedGuides.append(False)
					
class Trig_VoraciousReader(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["TurnEnds"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "At the end of turn, Shuma fills player's board with 1/1 Tentacles")
		HD = self.entity.Game.Hand_Deck
		while len(HD.hands[self.entity.ID]) < 3:
			if HD.drawCard(self.entity.ID)[0] is None: #假设疲劳1次的时候会停止抽牌
				break
				
				
class Trig_EducatedElekk(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["SpellPlayed"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		minion = self.entity
		PRINT(minion.Game, "Whenever player plays a spell, Educated Elekk memorizes it")
		for trig in self.entity.deathrattles:
			if isinstance(trig, ShuffleRememberedSpells):
				trig.spellsRemembered.append(type(subject))
				
class Trig_EnchantedCauldron(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["SpellBeenPlayed"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and subject.ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		self.disconnect()
		try: self.entity.trigsBoard.remove(self)
		except: pass
		curGame = self.entity.Game
		if curGame.mode == 0:
			PRINT(self.entity.Game, "After player casts a spell, Enchanted Cauldron casts another random spell of the same Cost.")
			if curGame.guides:
				spell = curGame.guides.pop(0)
			else:
				try: spell = npchoice(self.rngPool("%d-Cost Spells"%number))
				except: spell = None
				curGame.fixedGuides.append(spell)
			if spell:
				PRINT(curGame, "Enchanted Cauldron's Spellburst casts spell %s"%spell.name)
				spell(curGame, self.entity.ID).cast()
				
				
class Trig_CrimsonHothead(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["SpellBeenPlayed"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and subject.ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		self.disconnect()
		try: self.entity.trigsBoard.remove(self)
		except: pass
		PRINT(self.entity.Game, "After player plays a spell, Intrepid Initiate gains +2 Attack")
		self.entity.buffDebuff(1, 0)
		self.entity.getsKeyword("Taunt")
		
		
class Trig_WretchedTutor(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["SpellBeenPlayed"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and subject.ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		minion = self.entity
		self.disconnect()
		try: minion.trigsBoard.remove(self)
		except: pass
		PRINT(minion.Game, "After player casts a spell, Wretched Tutor deals 2 damage to all other minions.")
		targets = minion.Game.minionsonBoard(minion.ID, minion) + minion.Game.minionsonBoard(3-minion.ID)
		minion.dealsAOE(targets, [2 for minion in targets])
		
		
"""Mana 5 Cards"""
class Trig_HeadmasterKelThuzad(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["SpellPlayed", "SpellBeenPlayed", "MinionDied"])
		self.minionsKilled = []
		self.enabled = False
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		if signal == "MinionDied": return self.enabled
		else: return self.entity.onBoard and subject.ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		if signal == "SpellPlayed": self.enabled = True
		elif signal == "MinionDied": self.minionsKilled.append(type(target))
		else:
			self.disconnect()
			try: self.entity.trigsBoard.remove(self)
			except: pass
			minion = self.entity
			PRINT(minion.Game, "After player casts a spell, Headmaster Kel'Thuzad summons all minions killed by it.")
			if self.minionsKilled:
				minion.Game.summon([minionKilled(minion.Game, minion.ID) for minionKilled in self.minionsKilled], (minion.position, "totheRight"), minion.ID)
			
	def createCopy(self, game):
		if self not in game.copiedObjs: #这个扳机没有被复制过
			entityCopy = self.entity.createCopy(game)
			trigCopy = self.selfCopy(entityCopy)
			trigCopy.enabled = self.enabled
			trigCopy.minionsKilled = fixedList(self.minionsKilled)
			game.copiedObjs[self] = trigCopy
			return trigCopy
		else: #一个扳机被复制过了，则其携带者也被复制过了
			return game.copiedObjs[self]
			
			
class Trig_Ogremancer(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["SpellPlayed"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and subject.ID != self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "When player casts a spell, Ogremancer summons a 2/2 Skeleton with Taunt")
		self.entity.Game.summon(RisenSkeleton(self.entity.Game, self.entity.ID), self.entity.position+1, self.entity.ID)
		
class Trig_OnyxMagescribe(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["SpellBeenPlayed"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and subject.ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		self.disconnect()
		try: self.entity.trigsBoard.remove(self)
		except: pass
		curGame = self.entity.Game
		PRINT(curGame, "After player casts a spell, Onyx Magescribe adds 2 random spells from player's class to hand.")
		if curGame.mode == 0:
			if curGame.guides:
				spells = curGame.guides.pop(0)
			else:
				key = curGame.heroes[self.entity.ID].Class + " Spells"
				spells = npchoice(self.rngPool(key), 2, replace=True)
				curGame.fixedGuides.append(tuple(spells))
			curGame.Hand_Deck.addCardtoHand(spells, self.entity.ID, "type")
			
			
class Trig_KeymasterAlabaster(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["CardDrawn"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and target[0].ID != self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "Opponent draws a card, and Keymaster Alabaster adds a copy that costs (1) to player's hand")
		Copy = target[0].selfCopy(self.entity.ID)
		ManaMod(Copy, changeby=0, changeto=1).applies()
		self.entity.Game.Hand_Deck.addCardtoHand(Copy, self.entity.ID)
		
		
class Trig_TrueaimCrescent(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["HeroAttackedMinion"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		#The target can't be dying to trigger this
		return subject.ID == self.entity.ID and self.entity.onBoard and not target.dead and target.health > 0
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "After hero attacks minion %s, weapon Trueaim Crescent makes all friendly minions attack it too"%target.name)
		minions = self.entity.Game.minionsAlive(self.entity.ID)
		for minion in minions:
			if target.onBoard and target.health > 0 and not target.dead:
				self.entity.Game.battle(minion, target, verifySelectable=False, useAttChance=True, resolveDeath=False, resetRedirectionTriggers=True)
				
				
class Trig_AceHunterKreen(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["BattleStarted", "BattleFinished"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return subject.ID == self.entity.ID and subject != self.entity and self.entity.onBoard
		
	#不知道攻击具有受伤时召唤一个随从的扳机的随从时，飞刀能否对这个友方角色造成伤害
	#目前的写法是这个战斗结束信号触发在受伤之后
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		if signal == "BattleStarted":
			PRINT(self.entity.Game, "Before attack begins, Ace Hunter Kreen gives the attacking friendly character %s Immune"%subject.name)
			if subject.type == "Minion": subject.status["Immune"] += 1
			else: self.entity.Game.status[self.entity.ID]["Immune"] += 1
		else:
			PRINT(self.entity.Game, "After attack finished, Ace Hunter Kreen removes the Immune from the character %s."%subject.name)
			if subject.type == "Minion": subject.status["Immune"] -= 1
			else: self.entity.Game.status[self.entity.ID]["Immune"] -= 1
			
class Trig_Magehunter(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["MinionAttackingMinion"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return subject == self.entity and self.entity.onBoard
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "When Magehunter attacks minion %s, it gets Silenced"%target.name)
		target.getsSilenced()
		
		
class Trig_BloodHerald(TrigHand):
	def __init__(self, entity):
		self.blank_init(entity, ["MinionDies"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.inHand and target.ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		self.entity.buffDebuff(1, 1)
		
		
class Trig_FelGuardians(TrigHand):
	def __init__(self, entity):
		self.blank_init(entity, ["MinionDies"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.inHand and target.ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		ManaMod(self.entity, -1, -1).applies()
		
class Trig_AncientVoidHound(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["TurnEnds"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return ID == self.entity.ID and self.entity.onBoard
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "At the end of player's turn, Ancient Void Hound steals 1 Attack and Health from all enemy minions")
		enemyMinions = self.entity.Game.minionsonBoard(3-self.entity.ID)
		num = len(enemyMinions)
		for minion in enemyMinions:
			minion.attack -= 1
			minion.health -= 1
			minion.attack_Enchant -= 1
			for func in minion.triggers["StatChanges"]: func()
		if num: self.entity.buffDebuff(num, num)
		
		
"""Druid Cards"""
class Trig_Gibberling(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["SpellBeenPlayed"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and subject.ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		minion = self.entity
		self.disconnect()
		try: minion.trigsBoard.remove(self)
		except: pass
		PRINT(minion.Game, "After player casts a spell, Gibberling summons a Gibberling")
		minion.Game.summon(Gibberling(minion.Game, minion.ID), minion.position+1, minion.ID)
		
		
class Trig_SpeakerGidra(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["SpellBeenPlayed"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and subject.ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		self.disconnect()
		try: self.entity.trigsBoard.remove(self)
		except: pass
		PRINT(self.entity.Game, "After player casts a spell, Speaker Gidra gains %d Attack and Health"%number)
		self.entity.buffDebuff(number, number)
		
		
class Trig_TwilightRunner(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["MinionAttackingMinion", "MinionAttackingHero"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and subject == self.entity
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "When Twilight Runner attacks, player draws 2 cards")
		self.entity.Game.Hand_Deck.drawCard(self.entity.ID)
		self.entity.Game.Hand_Deck.drawCard(self.entity.ID)
		
		
class Trig_ForestWardenOmu(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["SpellBeenPlayed"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and subject.ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		self.disconnect()
		try: self.entity.trigsBoard.remove(self)
		except: pass
		PRINT(self.entity.Game, "After player casts a spell, Forest Warden Omu refreshes player's Mana Crystals.")
		self.entity.Game.Manas.restoreManaCrystal(0, self.entity.ID, restoreAll=True)
		
		
class Trig_KroluskBarkstripper(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["SpellBeenPlayed"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and subject.ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		self.disconnect()
		try: self.entity.trigsBoard.remove(self)
		except: pass
		curGame = self.entity.Game
		PRINT(curGame, "After player casts a spell, Krolusk Barkstripper destroys a random enemy minion")
		if curGame.mode == 0:
			if curGame.guides:
				i = curGame.guides.pop(0)
			else:
				minions = curGame.minionsAlive(3-self.entity.ID)
				i = npchoice(minions).position if minions else -1
				curGame.fixedGuides.append(i)
			if i > -1:
				curGame.killMinion(self.entity, curGame.minions[3-self.entity.ID][i])
				
				
class Trig_Firebrand(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["SpellBeenPlayed"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and subject.ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		self.disconnect()
		try: self.entity.trigsBoard.remove(self)
		except: pass
		curGame = self.entity.Game
		if curGame.mode == 0:
			PRINT(curGame, "After player casts a spell, Firebrand deals 4 damage randomly split among all enemy minions")
			for num in range(4):
				if curGame.guides:
					i = curGame.guides.pop(0)
				else:
					minions = curGame.minionsAlive(3-self.entity.ID)
					i = npchoice(minions).position if minions else -1
					curGame.fixedGuides.append(i)
				if i > -1:
					minion = curGame.minions[3-self.entity.ID][i]
					self.entity.dealsDamage(minion, 1)
				else: break
				
				
class Trig_JandiceBarov(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["MinionTakesDmg"])
		self.hide = True
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and target == self.entity
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "When %s takes damage, it dies"%self.entity.name)
		self.entity.Game.killMinion(None, self.entity)
		
		
class Trig_MozakiMasterDuelist(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["SpellBeenPlayed"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and subject.ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "After player casts a spell, Mozaki, Master Duelist gains Spell Damage +1")
		self.entity.getsKeyword("Spell Damage")
		
		
class Trig_WyrmWeaver(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["SpellBeenPlayed"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and subject.ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		minion = self.entity
		self.disconnect()
		try: minion.trigsBoard.remove(self)
		except: pass
		PRINT(minion.Game, "After player casts a spell, Wyrm Weaver summons two Mana Wyrms")
		pos = (self.position, "leftandRight") if self.onBoard else (-1, "totheRightEnd")
		minion.Game.summon([ManaWyrm(minion.Game, minion.ID) for i in range(2)], pos, minion.ID)
		
		
"""Paladin Cards"""
class Trig_GoodyTwoShields(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["SpellBeenPlayed"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and subject.ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		self.disconnect()
		try: self.entity.trigsBoard.remove(self)
		except: pass
		PRINT(self.entity.Game, "After player casts a spell, Goody Two-Shields gains Divine Shield.")
		self.entity.getsKeyword("Divine Shield")
		
		
class Trig_HighAbbessAlura(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["SpellBeenPlayed"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and subject.ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		self.disconnect()
		try: self.entity.trigsBoard.remove(self)
		except: pass
		curGame = self.entity.Game
		if curGame.mode == 0:
			PRINT(curGame, "After player casts a spell, High Abbess Alura casts a spell from player's deck")
			if curGame.guides:
				i = curGame.guides.pop(0)
			else:
				spells = [i for i, card in enumerate(curGame.Hand_Deck.decks[self.entity.ID]) if card.type == "Spell"]
				i = npchoice(spells) if spells else -1
				curGame.fixedGuides.append(i)
			if i > -1:
				spell = curGame.Hand_Deck.extractfromDeck(i, self.entity.ID)[0]
				PRINT(curGame, "High Abbess Alura cast spell %s from player's deck"%spell.name)
				spell.cast(None, comment="targetPrefered", preferedTarget=self.entity)
				curGame.gathertheDead()
				
				
class Trig_DevoutPupil(TrigHand):
	def __init__(self, entity):
		self.blank_init(entity, ["SpellBeenPlayed"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.inHand and target and subject.ID == target.ID and subject.ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		self.entity.Game.Manas.calcMana_Single(self.entity)
		
		
class Trig_TuralyontheTenured(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["MinionAttackingMinion"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and subject == self.entity
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "When Turalyon, the Tenured attacks minion %s, the defender's Attack and Health are set to 3"%target.name)
		target.statReset(3, 3)
		
"""Priest cards"""
class Trig_PowerWordFeast(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["TurnEnds"])
		self.inherent = False
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard #Even if the current turn is not minion's owner's turn
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		self.disconnect()
		try: self.entity.trigsBoard.remove(self)
		except: pass
		PRINT(self.entity.Game, "At the end of turn, minion %s is restored to full Health."%self.entity.name)
		heal = self.entity.health_max * (2 ** self.entity.countHealDouble())
		spell = PowerWordFeast(self.entity.Game, self.entity.ID)
		spell.restoresHealth(self.entity, heal)
		
		
class Trig_CabalAcolyte(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["SpellBeenPlayed"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and subject.ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		self.disconnect()
		try: self.entity.trigsBoard.remove(self)
		except: pass
		curGame = self.entity.Game
		if curGame.mode == 0:
			PRINT(curGame, "After player casts a spell, Cabal Acolyte gains control of a random enemy minion with 2 or less Attack.")
			if curGame.guides:
				i = curGame.guides.pop(0)
			else:
				#假设这个是临时控制，与暗影狂乱一致
				minions = [minion.position for minion in curGame.minionsAlive(3-self.entity.ID) if minion.attack < 3]
				i = npchoice(minions) if minions else -1
				curGame.fixedGuides.append(i)
			if i > -1: curGame.minionSwitchSide(curGame.minions[3-self.entity.ID][i])
			
			
class Trig_DisciplinarianGandling(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["MinionBeenPlayed"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and subject.ID == self.entity.ID and subject.onBoard
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		ID, game = self.entity.ID, self.entity.Game
		PRINT(game, "After player plays minion %s, Disciplinarian Gandling destroys it and summons a 4/4 Failed Student."%subject)
		position, subject.dead = subject.position, True
		game.gathertheDead()
		#Rule copied from Conjurer's Calling(Rise of Shadows)
		if position == 0: pos = -1 #Summon to the leftmost
		elif position < len(game.minionsonBoard(ID)): pos = position + 1
		else: pos = -1
		game.summon(FailedStudent(game, ID), pos, ID)
		
class Trig_FleshGiant(TrigHand):
	def __init__(self, entity):
		#假设这个费用改变扳机在“当你使用一张法术之后”。不需要预检测
		self.blank_init(entity, ["HeroChangedHealthinTurn"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.inHand and ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		self.entity.Game.Manas.calcMana_Single(self.entity)
		
		
"""Rogue Cards"""
class Trig_Plagiarize(SecretTrigger):
	def __init__(self, entity):
		self.blank_init(entity, ["TurnEnds"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.ID != ID and self.entity.Game.Counters.cardsPlayedThisTurn[3-self.entity.ID]["Indices"]
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		game = self.entity.Game
		cards = [game.cardPool[index] for index in game.Counters.cardsPlayedThisTurn[3-self.entity.ID]["Indices"]]
		PRINT(game, "At the end of turn, Secret Plagiarize is triggered and adds copies of opponent's cards played this turn")
		game.Hand_Deck.addCardtoHand(cards, self.entity.ID, "type")
		
		
class Trig_SelfSharpeningSword(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["HeroAttackedMinion", "HeroAttackedHero"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return subject.ID == self.entity.ID and self.entity.onBoard
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "After hero attacks, weapon Self-Sharpening Sword gains +1 Attack")
		self.entity.gainStat(1, 0)
		
		
class Trig_ShiftySophomore(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["SpellBeenPlayed"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and subject.ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		self.disconnect()
		try: self.entity.trigsBoard.remove(self)
		except: pass
		curGame = self.entity.Game
		if curGame.mode == 0:
			PRINT(curGame, "After player casts a spell, Shifty Sophomore adds a Combo card to player's hand")
			if curGame.guides:
				card = curGame.guides.pop(0)
			else:
				card = npchoice(self.rngPool("Combo Cards"))
				curGame.fixedGuides.append(card)
			curGame.Hand_Deck.addCardtoHand(card, self.entity.ID, "type")
			
			
class Trig_CuttingClass(TrigHand):
	def __init__(self, entity):
		self.blank_init(entity, ["WeaponEquipped", "WeaponRemoved", "WeaponAttChanges"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.inHand and ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		self.entity.Game.Manas.calcMana_Single(self.entity)
		
		
class Trig_DoctorKrastinov(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["MinionAttackingMinion", "MinionAttackingHero"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return subject == self.entity and self.entity.onBoard
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "When Doctor Krastinov attacks, player's weapon gain +1/+1")
		weapon = self.entity.Game.availableWeapon(self.entity.ID)
		if weapon: weapon.gainStat(1, 1)
		
"""Shaman Cards"""
class Trig_DiligentNotetaker(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["SpellBeenPlayed"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and subject.ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		self.disconnect()
		try: self.entity.trigsBoard.remove(self)
		except: pass
		PRINT(self.entity.Game, "After player casts a spell, Diligent Notetaker returns it to player's hand.")
		self.entity.Game.Hand_Deck.addCardtoHand(type(subject), self.entity.ID, "type")
		
		
class Trig_RuneDagger(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["HeroAttackedHero", "HeroAttackedMinion"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return subject == self.entity.Game.heroes[self.entity.ID] and self.entity.onBoard
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "After player attacks, Rune Dagger gives player Spell Damage +1 this turn.")
		self.entity.Game.status[self.entity.ID]["Spell Damage"] += 1
		self.entity.Game.turnEndTrigger.append(SpellDamagePlus1Disappears(self.entity.Game, self.entity.ID))
		
class Trig_TrickTotem(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["TurnEnds"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		curGame = self.entity.Game
		if curGame.mode == 0:
			PRINT(self.entity.Game, "At the end of turn, Trick Totem casts a random spell that costs (3) or less.")
			if curGame.guides:
				spell = curGame.guides.pop(0)
			else:
				spell = npchoice(self.rngPool("Spells of <=3 Cost"))
				curGame.fixedGuides.append(spell)
			PRINT(curGame, "Trick Totem's casts spell "%spell.name)
			spell(curGame, self.entity.ID).cast()
			
			
class Trig_RasFrostwhisper(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["TurnEnds"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		minion = self.entity
		damage = 1 + minion.countSpellDamage()
		PRINT(minion.Game, "At the end of turn, Ras Frostwhisper deals 1 damage to all enemies.")
		targets = [minion.Game.heroes[3-minion.ID]] + minion.Game.minionsonBoard(3-minion.ID)
		minion.dealsAOE(targets, [damage] * len(targets))
		
		
class Trig_CeremonialMaul(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["SpellBeenPlayed"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return subject.ID == self.entity.ID and self.entity.onBoard
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		self.disconnect()
		try: self.entity.trigsBoard.remove(self)
		except: pass
		game, stat = self.entity.Game, number
		PRINT(game, "After player casts a spell %s, Ceremonial Maul summons a Student with Taunt and stat equal to its Cost."%subject.name)
		if stat and game.space(self.entity.ID):
			cost = min(stat, 10)
			newIndex = "Academy~Warrior,Paladin~%d~%d~%d~Minion~None~Honor Student~Taunt~Uncollectible"%(cost, stat, stat)
			subclass = type("HonorStudent_Mutable_%d"%stat, (HonorStudent_Mutable_1, ),
							{"mana": cost, "attack": stat, "health": stat,
							"index": newIndex}
							)
			game.cardPool[newIndex] = subclass
			game.summon(subclass(game, self.entity.ID), -1, self.entity.ID)
			
class Trig_Playmaker(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["MinionBeenPlayed"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and subject.ID == self.entity.ID and subject.keyWords["Rush"] > 0
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "After player plays minion, Playmaker summons a 1 Health copy of it")
		Copy = subject.selfCopy(self.entity.ID)
		Copy.health = 1
		self.entity.Game.summon(Copy, self.entity.position+1, self.entity.ID)
		
		
class Trig_ReapersScythe(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["SpellBeenPlayed"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return subject.ID == self.entity.ID and self.entity.onBoard
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		self.disconnect()
		try: self.entity.trigsBoard.remove(self)
		except: pass
		self.entity.marks["Sweep"] += 1
		trig = Trig_SweepThisTurn(self.entity)
		trig.connect()
		self.entity.trigsBoard.append(trig)
		
class Trig_SweepThisTurn(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["TurnEnds"])
		self.inherent = False
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard #Even if the current turn is not minion's owner's turn
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		self.disconnect()
		try: self.entity.trigsBoard.remove(self)
		except: pass
		PRINT(self.entity.Game, "At the end of turn, Reaper's Scythe loses 'Damages adjacent minions'.")
		self.entity.marks["Sweep"] -= 1
		
		
class Trig_Troublemaker(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["TurnEnds"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		curGame = self.entity.Game
		PRINT(curGame, "At the end of turn, Troublemaker summons two 3/3 Ruffians that attack random enemies")
		ruffians = [Ruffian(curGame, self.entity.ID) for i in range(2)]
		curGame.summon(ruffians, (self.entity.position, "leftandRight"), self.entity.ID)
		if curGame.mode == 0:
			for num in range(2):
				enemy = None
				if curGame.guides:
					i, where = curGame.guides.pop(0)
					if where: enemy = curGame.find(i, where)
				else:
					targets = curGame.charsAlive(3-self.entity.ID)
					if ruffians[num].onBoard and not ruffians[num].dead and ruffians[num].health > 0 and targets:
						enemy = npchoice(targets)
						curGame.fixedGuides.append((enemy.position, enemy.type+str(enemy.ID)))
					else:
						curGame.fixedGuides.append((0, ''))
				if enemy: curGame.battle(ruffians[num], enemy, verifySelectable=False, resolveDeath=False)
				
Inspecting Darkmoon.py
class Trig_Corrupt(TrigHand):
	def __init__(self, entity, corruptedType):
		self.blank_init(entity, ["ManaPaid"])
		self.corruptedType = corruptedType
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.inHand and ID == self.entity.ID and number > self.entity.mana and subject.type != "Power"
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		card = self.entity
		newCard = self.corruptedType(card.Game, card.ID)
		try:
			#Buff and mana effects, etc, will be preserved
			#Buff to cards in hand will always be permanent or temporary, not from Auras
			if newCard.type == "Minion":
				#Temporary attack changes on minions are NOT included in attack_Enchant
				attBuff, healthBuff = card.attack_Enchant - card.attack_0, card.health_max - card.health_0
				newCard.buffDebuff(attBuff, healthBuff)
				for attGain, attRevertTime in card.tempAttChanges:
					newCard.buffDebuff(attGain, 0, attRevertTime)
				#There are no Corrupted cards with predefined Deathrattles, and given Deathrattles are very simple
				newCard.deathrattles = [type(deathrattle)(newCard) for deathrattle in card.deathrattles]
			elif newCard.type == "Weapon": #Only applicable to Felsteel Executioner
				attBuff, healthBuff = card.attack_Enchant - card.attack_0, card.health_max - card.health_0
				#Assume temporary attack changes applied on a minion won't carry over to the weapon
				newCard.gainStat(attBuff, healthBuff)
			#Keep the keywords and marks consistent
			for key, value in newCard.keyWords.items(): #Find keywords the new card doesn't have
				if value < 1 and card.keyWords[key] > 0: newCard.keyWords[key] = 1
			for key, value in newCard.marks.items():
				try:
					if value < 1 and card.marks[key] > 0: newCard.marks[key] = 1
				except: pass
			#Inhand triggers and mana modifications
			newCard.trigsHand += [trig for trig in card.trigsHand if not isinstance(trig, Trig_Corrupt)]
			newCard.manaMods = [manaMod.selfCopy(newCard) for manaMod in card.manaMods]
		except Exception as e:
			print(e, card, newCard)
		print("Corruption of ", card, newCard)
		card.Game.Hand_Deck.replaceCardinHand(card, newCard)
		
	def selfCopy(self, recipient):
		return type(self)(recipient, self.corruptedType)
		
	def createCopy(self, game):
		if self not in game.copiedObjs: #这个扳机没有被复制过
			entityCopy = self.entity.createCopy(game)
			trigCopy = type(self)(entityCopy, self.corruptedType)
			game.copiedObjs[self] = trigCopy
			return trigCopy
		else: #一个扳机被复制过了，则其携带者也被复制过了
			return game.copiedObjs[self]
			
			
"""Mana 1 cards"""
class Trig_EndlessCorrupt(TrigHand):
	def __init__(self, entity):
		self.blank_init(entity, ["ManaPaid"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.inHand and ID == self.entity.ID and number > self.entity.mana and subject.type != "Power"
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		card = self.entity
		stat = int(type(card).__name__.split('_')[-1]) + 1
		print("Creating a %d Horrendous Growth"%stat)
		newIndex = "Darkmoon~Neutral~2~%d~%d~Minion~None~Horrendous Growth~Corrupted~Uncollectible"%(stat, stat)
		subclass = type("HorrendousGrowthCorrupt_Mutable_"+str(stat), (HorrendousGrowthCorrupt_Mutable_3, ),
						{"attack": stat, "health": stat, "index": newIndex}
						)
		card.Game.cardPool[newIndex] = subclass
		#The buffs on the cards carry over
		newCard = subclass(card.Game, card.ID)
		#Buff and mana effects, etc, will be preserved
		#Buff to cards in hand will always be permanent or temporary, not from Auras
		#Temporary attack changes on minions are NOT included in attack_Enchant
		attBuff, healthBuff = card.attack_Enchant - card.attack_0, card.health_max - card.health_0
		newCard.buffDebuff(attBuff, healthBuff)
		for attGain, attRevertTime in card.tempAttChanges:
			newCard.buffDebuff(attGain, 0, attRevertTime)
		#Find keywords the new card doesn't have
		keyWords = newCard.keyWords.keys()
		#Since the Horrendous Growth has no predefined keywords, it can simply copy the predecessors
		newCard.keyWords, newCard.marks = copy.deepcopy(card.keyWords), copy.deepcopy(card.marks)
		newCard.trigsHand += [trig for trig in card.trigsHand if not isinstance(trig, Trig_EndlessCorrupt)]
		#There are no Corrupted cards with predefined Deathrattles
		newCard.deathrattles = [type(deathrattle)(newCard) for deathrattle in card.deathrattles]
		#Mana modifications
		newCard.manaMods = [manaMod.selfCopy(newCard) for manaMod in card.manaMods]
		
		card.Game.Hand_Deck.replaceCardinHand(card, newCard)
		
		
class Trig_ParadeLeader(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["MinionBeenSummoned"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and subject.ID == self.entity.ID and subject != self.entity and subject.keyWords["Rush"] > 0
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "After player summons Rush minion %s, Parade Leader gives it +2 Attack"%subject.name)
		subject.buffDebuff(2, 0)
		
		
class Trig_OptimisticOgre(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["MinionAttacksMinion", "MinionAttacksHero", "BattleFinished"])
		self.trigedThisBattle = False
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		#The trigger can be reset any time by "BattleFinished".
		#Otherwise, can only trigger if there are enemies other than the target.
		#游荡怪物配合误导可能会将对英雄的攻击目标先改成对召唤的随从，然后再发回敌方英雄，说明攻击一个错误的敌人应该也是游戏现记录的目标之外的角色。
		return not signal.startswith("Minion") or (subject == self.entity and self.entity.onBoard and target[1] and not self.trigedThisBattle \
													and self.entity.Game.charsAlive(3-subject.ID, target[1]) \
													)
													
	def trigger(self, signal, ID, subject, target, number, comment, choice=0):
		if self.entity.onBoard:
			if signal == "BattleFinished": #Reset the Forgetful for next battle event.
				self.trigedThisBattle = False
			elif target: #Attack signal
				curGame, side = self.entity.Game, 3- self.entity.ID
				if curGame.mode == 0:
					char, redirect = None, 0
					if curGame.guides:
						i, where, redirect = curGame.guides.pop(0)
						if where: char = curGame.find(i, where)
					else:
						otherEnemies = curGame.charsAlive(side, target[1])
						if otherEnemies:
							char, redirect = npchoice(otherEnemies), nprandint(2)
							curGame.fixedGuides.append((char.position, char.type+str(char.ID), redirect))
						else:
							curGame.fixedGuides.append((0, '', 0))
					if char and redirect: #Redirect is 0/1, indicating whether the attack will redirect or not
						#玩家命令的一次攻击中只能有一次触发机会。只要满足进入50%判定的条件，即使没有最终生效，也不能再次触发。
						PRINT(curGame, "Optimistic Ogre redirects its attack onto %s"%char.name)
						target[1], self.trigedThisBattle = char, True
						
"""Mana 6 cards"""
class Trig_CThun:
	def __init__(self, Game, ID):
		self.Game, self.ID = Game, ID
		self.pieces = ["Body", "Eye", "Heart", "Maw"]
		
	def connect(self):
		try: self.Game.trigsBoard[self.ID]["CThunPiece"].append(self)
		except: self.Game.trigsBoard[self.ID]["CThunPiece"] = [self]
		
	def disconnect(self):
		try: self.Game.trigsBoard[self.ID]["CThunPiece"].remove(self)
		except: pass
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		print("Checking if CThun piece", ID == self.ID)
		return ID == self.ID
		
	def trigger(self, signal, ID, subject, target, number, comment, choice=0):
		if self.canTrigger(signal, ID, subject, target, number, comment):
			if self.Game.GUI: self.Game.GUI.showOffBoardTrig(CThuntheShattered(self.Game, self.ID), linger=False)
			self.effect(signal, ID, subject, target, number, comment)
			
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		if ID == self.ID and number not in self.pieces:
			try: self.pieces.remove(comment)
			except: pass
			PRINT(self.Game, "Player {}'s C'Thun has {} missing".format(ID, self.pieces))
			if not self.pieces:
				PRINT(self.Game, "Player %d's C'Thun is completed and shuffles into the deck"%ID)
				self.Game.Hand_Deck.shuffleCardintoDeck(CThuntheShattered(self.Game, ID), ID)
				self.disconnect()
				
	def createCopy(self, game): #不是纯的只在回合结束时触发，需要完整的createCopy
		if self not in game.copiedObjs: #这个扳机没有被复制过
			trigCopy = type(self)(game, self.ID)
			trigCopy.pieces = [s for s in self.pieces]
			game.copiedObjs[self] = trigCopy
			return trigCopy
		else: #一个扳机被复制过了，则其携带者也被复制过了
			return game.copiedObjs[self]
			
class Trig_RedeemedPariah(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["MinionBeenPlayed", "SpellBeenPlayed", "WeaponBeenPlayed", "HeroCardBeenPlayed"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and subject.ID == self.entity.ID and "~Outcast" in subject.index
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "Player plays an Outcast card and Redeemed Pariah gains +1/+1.")
		self.entity.buffDebuff(1, 1)
		
		
class Trig_BladedLady(TrigHand):
	def __init__(self, entity):
		self.blank_init(entity, ["HeroAttCalc"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.inHand and ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		self.entity.Game.Manas.calcMana_Single(self.entity)
		
		
class Trig_UmbralOwl(TrigHand):
	def __init__(self, entity):
		#假设这个费用改变扳机在“当你使用一张法术之后”。不需要预检测
		self.blank_init(entity, ["SpellBeenPlayed"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.inHand and subject.ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		self.entity.Game.Manas.calcMana_Single(self.entity)
		
		
class Trig_OpentheCages(SecretTrigger):
	def __init__(self, entity):
		self.blank_init(entity, ["TurnStarts"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0): #target here holds the actual target object
		secret = self.entity
		return secret.ID == ID and len(secret.Game.minionsonBoard(secret.ID)) > 1 and secret.Game.space(secret.ID) > 0
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		curGame = self.entity.Game
		PRINT(curGame, "At the start of player's turn, Secret Open the Cages is triggered and summons an Animal Companion.")
		if curGame.mode == 0:
			if curGame.guides:
				companion = curGame.guides.pop(0)
			else:
				companion = npchoice([Huffer, Leokk, Misha])
				curGame.fixedGuides.append(companion)
			PRINT(curGame, "Animal Companion is cast and summons random Animal Companion %s"%companion.name)
			curGame.summon(companion(curGame, self.entity.ID), -1, self.entity.ID)
			
			
class Trig_RinlingsRifle(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["HeroAttackedMinion", "HeroAttackedHero"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return subject == self.entity.Game.heroes[self.entity.ID] and self.entity.onBoard
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		weapon, curGame = self.entity, self.entity.Game
		if curGame.mode == 0:
			PRINT(curGame, "After player attacks, Rinling's Rifle lets player Discover a Secret and cast it")
			if curGame.guides:
				curGame.guides.pop(0)(curGame, weapon.ID).cast()
			else:
				HeroClass = curGame.heroes[weapon.ID].Class
				key = HeroClass + " Secrets" if HeroClass in ["Hunter", "Mage", "Paladin", "Rogue"] else "Hunter Secrets"
				secrets = self.rngPool(key)
				for secret in curGame.Secrets.secrets[weapon.ID]:
					try: secrets.remove(type(secret)) #Deployed Secrets won't show up in the options
					except: pass
				secrets = npchoice(secrets, min(len(secrets), 3), replace=False)
				curGame.options = [secret(curGame, weapon.ID) for secret in secrets]
				curGame.Discover.startDiscover(weapon)
				
				
class Trig_TramplingRhino(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["MinionAttackedMinion"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and subject == self.entity and target.health < 0
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		excessDmg = -target.health
		PRINT(self.entity.Game, "After Trampling Rhino attacks and kills a minion %s, it deals the excess damage to the enemy hero."%target.name)
		self.entity.dealsDamage(self.entity.Game.heroes[3-self.entity.ID], excessDmg)
		
#Even minions with "Can't attack heroes" still attack hero under her command
class Trig_RiggedFaireGame(SecretTrigger):
	def __init__(self, entity):
		self.blank_init(entity, ["TurnEnds"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0): #target here holds the actual target object
		return self.entity.ID != ID and self.entity.Game.Counters.dmgonHero_inOppoTurn[self.entity.ID] == 0
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "Player took no damage in opponent's turn, Secret Rigged Faire Game is triggered and player draws 3 cards.")
		self.entity.Game.Hand_Deck.drawCard(self.entity.ID)
		self.entity.Game.Hand_Deck.drawCard(self.entity.ID)
		self.entity.Game.Hand_Deck.drawCard(self.entity.ID)

		
class Trig_OhMyYogg(SecretTrigger):
	def __init__(self, entity):
		self.blank_init(entity, ["SpellOKtoCast?"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return subject[0].ID != self.entity.ID and subject is not None
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		curGame = self.entity.Game
		PRINT(curGame, "Secret Oh My Yogg! turns the spell %s the opponent plays into a randomly cast one of the same cost"%subject[0].name)
		if curGame.mode == 0:
			if curGame.guides:
				newSpell = curGame.guides.pop(0)
			else:
				newSpell = npchoice(self.rngPool("%d-Cost Spells"%number))
				curGame.fixedGuides.append(newSpell)
			subject[0] = newSpell(curGame, 3-self.entity.ID)
			
			
class Trig_CarnivalBarker(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["MinionSummoned"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and subject.ID == self.entity.ID and subject.health == 1 and subject != self.entity
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "A friendly 1-Health minion %s is summoned and Carnival Barker gains +1/+2"%subject.name)
		subject.buffDebuff(1, 2)
		
		
class Trig_NazmaniBloodweaver(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["SpellBeenPlayed"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and subject.ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		curGame = self.entity.Game
		if curGame.mode == 0:
			PRINT(curGame, "After player casts spell, Nazmani Bloodweaver reduces the Cost of a random card in player's hand by (1)")
			if curGame.guides:
				i = curGame.guides.pop(0)
			else:
				num = len(curGame.Hand_Deck.hands[self.entity.ID])
				i = nprandint(num) if num else -1
			if i > -1:
				ManaMod(curGame.Hand_Deck.hands[self.entity.ID][i], changeby=-1, changeto=-1).applies()
				
				
class Trig_BloodofGhuun(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["TurnEnds"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		minion = self.entity
		curGame = minion.Game
		if curGame.mode == 0:
			PRINT(curGame, "At the end of turn, Blood of G'huun summons a 5/5 copy of a minion in played's deck")
			if curGame.guides:
				i = curGame.guides.pop(0)
			else:
				minions = [i for i, card in enumerate(curGame.Hand_Deck.decks[minion.ID]) if card.type == "Minion"]
				i = npchoice(minions) if minions and curGame.space(minion.ID) > 0 else -1
				curGame.fixedGuides.append(i)
			if i > -1:
				Copy = curGame.Hand_Deck.decks[minion.ID][i].selfCopy(minion.ID, 5, 5)
				curGame.summon(Copy, minion.position+1, minion.ID)
			
"""Rogue cards"""
class Trig_ShadowClone(SecretTrigger):
	def __init__(self, entity):
		self.blank_init(entity, ["MinionAttackedHero"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.ID != self.entity.Game.turn and target == self.entity.Game.heroes[self.entity.ID]
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "After a minion %s attacks player, Secret Shadow Clone is triggered and summons a copy of it with Stealth"%subject.name)
		Copy = subject.selfCopy(self.entity.ID)
		self.entity.Game.summon(Copy, -1, self.entity.ID)
		
		
class Trig_MalevolentStrike(TrigHand):
	def __init__(self, entity):
		self.blank_init(entity, ["DeckCheck"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.inHand and ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		self.entity.Game.Manas.calcMana_Single(self.entity)
		
		
class Trig_GrandTotemEysor(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["TurnEnds"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and ID == self.entity.ID
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		curGame, side = self.entity.Game, self.entity.ID
		PRINT(curGame, "At the end of turn, Grand Totem Eys'or gives +1/+1 to all other Totems in player's hand, deck and battlefield")
		for obj in curGame.minionsonBoard(side):
			if "Totem" in obj.race and obj != self.entity:
				obj.buffDebuff(1, 1)
		for card in curGame.Hand_Deck.hands[side] + curGame.Hand_Deck.decks[side]:
			if card.type == "Minion" and "Totem" in card.race:
				card.buffDebuff(1, 1)
				
				
class Trig_Magicfin(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["MinionDies"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return self.entity.onBoard and target != self.entity and target.ID == self.entity.ID and "Murloc" in target.race #Technically, minion has to disappear before dies. But just in case.
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		curGame = self.entity.Game
		PRINT(curGame, "A friendly Murloc %s dies and Magicfin adds a random Legendary minion to player's hand."%target.name)
		if curGame.mode == 0:
			if curGame.guides:
				minion = curGame.guides.pop(0)
			else:
				minion = npchoice(self.rngPool("Legendary Minions"))
				curGame.fixedGuides.append(minion)
			curGame.Hand_Deck.addCardtoHand(minion, self.entity.ID, "type")
			
			
class Trig_WhackAGnollHammer(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["HeroAttackedMinion", "HeroAttackedHero"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return subject == self.entity.Game.heroes[self.entity.ID] and self.entity.onBoard
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		curGame = self.entity.Game
		PRINT(curGame, "After player attacks, weapon  gives a random friendly minion +1/+1")
		if curGame.mode == 0:
			if curGame.guides:
				i, where = curGame.guidies.pop(0)
			else:
				minions = curGame.minionsonBoard(self.entity.ID)
				i = npchoice(minions).position if minions else -1
				curGame.fixedGuides.append(i)
			if i > -1: curGame.minions[self.entity.ID][i].buffDebuff(1, 1)
			
			
class Trig_ETCGodofMetal(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["MinionAttackedMinion", "MinionAttackedHero"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return subject.ID == self.entity.ID and subject.keyWords["Rush"] > 0 and self.entity.onBoard
		
	#不知道攻击具有受伤时召唤一个随从的扳机的随从时，飞刀能否对这个友方角色造成伤害
	#目前的写法是这个战斗结束信号触发在受伤之后
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		PRINT(self.entity.Game, "After friendly minion %s attacks, E.T.C., God of Metal deals 2 damage to the enemy hero"%subject.name)
		self.entity.dealsDamage(self.entity.Game.heroes[3-self.entity.ID], 2)
		
		
class Trig_RingmastersBaton(TrigBoard):
	def __init__(self, entity):
		self.blank_init(entity, ["HeroAttackedMinion", "HeroAttackedHero"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		return subject == self.entity.Game.heroes[self.entity.ID] and self.entity.onBoard
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		curGame = self.entity.Game
		ownHand = curGame.Hand_Deck.hands[self.entity.ID]
		PRINT(curGame, "After player attacks, weapon Ringmaster's Baton gives a Mech, Dragon, and Pirate in player's hand +1/+1")
		if curGame.mode == 0:
			for race in ["Mech", "Dragon", "Pirate"]:
				if curGame.guides:
					i = curGame.guidies.pop(0)
				else:
					minions = [i for i, card in enumerate(ownHand) if card.type == "Minion" and race in card.race]
					i = npchoice(minions) if minions else -1
					curGame.fixedGuides.append(i)
				if i > -1: ownHand[i].buffDebuff(1, 1)
				
				
class Trig_TentTrasher(TrigHand):
	def __init__(self, entity):
		self.blank_init(entity, ["MinionAppears", "MinionDisappears"])
		
	def canTrigger(self, signal, ID, subject, target, number, comment, choice=0):
		if 'A' in signal: return self.entity.inHand and ID == self.entity.ID and subject.race
		else: return self.entity.inHand and ID == self.entity.ID and target.race
		
	def effect(self, signal, ID, subject, target, number, comment, choice=0):
		self.entity.Game.Manas.calcMana_Single(self.entity)
		
		
Darkmoon_Indices  = {"Darkmoon~Neutral~Minion~1~1~3~None~Safety Inspector~Battlecry": SafetyInspector,
					"Darkmoon~Neutral~Minion~2~1~2~None~Costumed Entertainer~Battlecry": CostumedEntertainer,
					"Darkmoon~Neutral~Minion~2~2~2~None~Horrendous Growth": HorrendousGrowth,
					"Darkmoon~Neutral~Minion~2~3~3~None~Horrendous Growth~Corrupted~Uncollectible": HorrendousGrowthCorrupt_Mutable_3,
					"Darkmoon~Neutral~Minion~2~2~3~None~Parade Leader": ParadeLeader,
					"Darkmoon~Neutral~Minion~2~2~3~Murloc~Prize Vendor~Battlecry": PrizeVendor,
					"Darkmoon~Neutral~Minion~2~5~1~Elemental~Rock Rager~Taunt": RockRager,
					"Darkmoon~Neutral~Minion~2~3~2~None~Showstopper~Deathrattle": Showstopper,
					"Darkmoon~Neutral~Minion~2~2~1~None~Wriggling Horror~Battlecry": WrigglingHorror,
					"Darkmoon~Neutral~Minion~3~2~4~None~Banana Vendor~Battlecry": BananaVendor,
					"Darkmoon~Neutral~Minion~3~3~2~Mech~Darkmoon Dirigible~Divine Shield": DarkmoonDirigible,
					"Darkmoon~Neutral~Minion~3~3~2~Mech~Darkmoon Dirigible~Divine Shield~Rush~Corrupted~Uncollectible": DarkmoonDirigible_Corrupt,
					"Darkmoon~Neutral~Minion~3~0~5~None~Darkmoon Statue": DarkmoonStatue,
					"Darkmoon~Neutral~Minion~3~4~5~None~Darkmoon Statue~Corrupted~Uncollectible": DarkmoonStatue_Corrupt,
					"Darkmoon~Neutral~Minion~3~3~2~Elemental~Gyreworm~Battlecry": Gyreworm,
					"Darkmoon~Neutral~Minion~3~2~2~None~Inconspicuous Rider~Battlecry": InconspicuousRider,
					"Darkmoon~Neutral~Minion~3~4~4~None~K'thir Ritualist~Taunt~Battlecry": KthirRitualist,
					"Darkmoon~Neutral~Minion~4~4~5~Elemental,Mech,Demon,Murloc,Dragon,Beast,Pirate,Totem~Circus Amalgam~Taunt": CircusAmalgam,
					"Darkmoon~Neutral~Minion~4~3~4~None~Circus Medic~Battlecry": CircusMedic,
					"Darkmoon~Neutral~Minion~4~3~4~None~Circus Medic~Battlecry~Corrupted~Uncollectible": CircusMedic_Corrupt,
					"Darkmoon~Neutral~Minion~4~3~5~Elemental~Fantastic Firebird~Windfury": FantasticFirebird,
					"Darkmoon~Neutral~Minion~4~3~4~None~Knife Vendor~Battlecry": KnifeVendor,
					"Darkmoon~Neutral~Minion~5~3~2~None~Derailed Coaster~Battlecry": DerailedCoaster,
					"Darkmoon~Neutral~Minion~1~1~1~None~Darkmoon Rider~Rush~Uncollectible": DarkmoonRider,
					"Darkmoon~Neutral~Minion~5~4~4~Beast~Fleethoof Pearltusk~Rush": FleethoofPearltusk,
					"Darkmoon~Neutral~Minion~5~8~8~Beast~Fleethoof Pearltusk~Rush~Corrupted~Uncollectible": FleethoofPearltusk_Corrupt,
					"Darkmoon~Neutral~Minion~5~6~7~None~Optimistic Ogre": OptimisticOgre,
					"Darkmoon~Neutral~Minion~6~6~3~Mech~Claw Machine~Rush~Deathrattle": ClawMachine,
					"Darkmoon~Neutral~Minion~7~4~4~None~Silas Darkmoon~Battlecry~Legendary": SilasDarkmoon,
					"Darkmoon~Neutral~Minion~7~6~6~None~Strongman~Taunt": Strongman,
					"Darkmoon~Neutral~Minion~0~6~6~None~Strongman~Taunt~Corrupted~Uncollectible": Strongman_Corrupt,
					"Darkmoon~Neutral~Minion~9~4~4~None~Carnival Clown~Taunt~Battlecry": CarnivalClown,
					"Darkmoon~Neutral~Minion~9~4~4~None~Carnival Clown~Taunt~Battlecry~Corrupted~Uncollectible": CarnivalClown_Corrupt,
					"Darkmoon~Neutral~Spell~5~Body of C'Thun~Uncollectible": BodyofCThun,
					"Darkmoon~Neutral~Minion~6~6~6~None~Body of C'Thun~Taunt~Uncollectible": BodyofCThun_Minion,
					"Darkmoon~Neutral~Spell~5~Eye of C'Thun~Uncollectible": EyeofCThun,
					"Darkmoon~Neutral~Spell~5~Heart of C'Thun~Uncollectible": HeartofCThun,
					"Darkmoon~Neutral~Spell~5~Maw of C'Thun~Uncollectible": MawofCThun,
					"Darkmoon~Neutral~Minion~10~6~6~None~C'Thun, the Shattered~Battlecry~Start of Game~Legendary": CThuntheShattered,
					"Darkmoon~Neutral~Minion~10~1~1~Beast~Darkmoon Rabbit~Rush~Poisonous": DarkmoonRabbit,
					"Darkmoon~Neutral~Minion~10~5~7~None~N'Zoth, God of the Deep~Battlecry~Legendary": NZothGodoftheDeep,
					"Darkmoon~Neutral~Minion~10~7~5~None~Yogg-Saron, Master of Fate~Battlecry~Legendary": YoggSaronMasterofFate,
					"Darkmoon~Neutral~Spell~0~Curse of Flesh~Uncollectible": CurseofFlesh,
					"Darkmoon~Neutral~Spell~0~Hand of Fate~Uncollectible": HandofFate,
					"Darkmoon~Neutral~Minion~10~10~10~None~Y'Shaarj, the Defiler~Battlecry~Legendary": YShaarjtheDefiler,
					#Demon Hunter Cards
					"Darkmoon~Demon Hunter~Spell~1~Felscream Blast~Lifesteal": FelscreamBlast,
					"Darkmoon~Demon Hunter~Spell~1~Throw Glaive": ThrowGlaive,
					"Darkmoon~Demon Hunter~Minion~2~2~3~None~Redeemed Pariah": RedeemedPariah,
					"Darkmoon~Demon Hunter~Spell~3~Acrobatics": Acrobatics,
					"Darkmoon~Demon Hunter~Weapon~3~3~2~Dreadlord's Bite~Outcast": DreadlordsBite,
					"Darkmoon~Demon Hunter~Minion~3~4~3~Elemental~Felsteel Executioner": FelsteelExecutioner,
					"Darkmoon~Demon Hunter~Weapon~3~4~3~Felsteel Executioner~Corrupted~Uncollectible": FelsteelExecutioner_Corrupt,
					"Darkmoon~Demon Hunter~Minion~3~3~4~None~Line Hopper": LineHopper,
					"Darkmoon~Demon Hunter~Minion~3~2~5~Demon~Insatiable Felhound~Taunt": InsatiableFelhound,
					"Darkmoon~Demon Hunter~Minion~3~3~6~Demon~Insatiable Felhound~Taunt~Lifesteal~Corrupt~Uncollectible": InsatiableFelhound_Corrupt,
					"Darkmoon~Demon Hunter~Spell~3~Relentless Pursuit": RelentlessPursuit,
					"Darkmoon~Demon Hunter~Minion~3~4~1~None~Stiltstepper~Battlecry": Stiltstepper,
					"Darkmoon~Demon Hunter~Minion~4~2~6~None~Il'gynoth~Lifesteal~Legendary": Ilgynoth,
					"Darkmoon~Demon Hunter~Minion~4~3~3~None~Renowned Performer~Rush~Deathrattle": RenownedPerformer,
					"Darkmoon~Demon Hunter~Minion~1~1~1~None~Performer's Assistant~Taunt~Uncollectible": PerformersAssistant,
					"Darkmoon~Demon Hunter~Minion~5~5~3~None~Zai, the Incredible~Battlecry": ZaitheIncredible,
					"Darkmoon~Demon Hunter~Minion~6~6~6~Demon~Bladed Lady~Rush": BladedLady,
					"Darkmoon~Demon Hunter~Spell~7~Expendable Performers": ExpendablePerformers,
					#Druid Cards
					"Darkmoon~Druid~Spell~2~Guess the Weight": GuesstheWeight,
					"Darkmoon~Druid~Spell~2~Lunar Eclipse": LunarEclipse,
					"Darkmoon~Druid~Spell~2~Solar Eclipse": SolarEclipse,
					"Darkmoon~Druid~Minion~3~2~2~None~Faire Arborist~Choose One": FaireArborist,
					"Darkmoon~Druid~Minion~3~2~2~None~Faire Arborist~Corrupted~Uncollectible": FaireArborist_Corrupt,
					"Darkmoon~Druid~Spell~3~Moontouched Amulet": MoontouchedAmulet,
					"Darkmoon~Druid~Spell~3~Moontouched Amulet~Corrupted~Uncollectible": MoontouchedAmulet_Corrupt,
					"Darkmoon~Druid~Minion~4~2~2~None~Kiri, Chosen of Elune~Battlecry~Legendary": KiriChosenofElune,
					"Darkmoon~Druid~Minion~5~4~6~None~Greybough~Taunt~Deathrattle~Legendary": Greybough,
					"Darkmoon~Druid~Minion~7~4~4~Beast~Umbral Owl~Rush": UmbralOwl,
					"Darkmoon~Druid~Spell~8~Cenarion Ward": CenarionWard,
					"Darkmoon~Druid~Minion~9~10~10~Elemental~Fizzy Elemental~Rush~Taunt": FizzyElemental,
					#Hunter Cards
					"Darkmoon~Hunter~Minion~1~1~1~None~Mystery Winner~Battlecry": MysteryWinner,
					"Darkmoon~Hunter~Minion~2~1~5~Beast~Dancing Cobra": DancingCobra,
					"Darkmoon~Hunter~Minion~2~1~5~Beast~Dancing Cobra~Poisonous~Corrupted~Uncollectible": DancingCobra_Corrupt,
					"Darkmoon~Hunter~Spell~2~Don't Feed the Animals": DontFeedtheAnimals,
					"Darkmoon~Hunter~Spell~2~Don't Feed the Animals~Corrupted~Uncollectible": DontFeedtheAnimals_Corrupt,
					"Darkmoon~Hunter~Spell~2~Open the Cages~~Secret": OpentheCages,
					"Darkmoon~Hunter~Spell~3~Petting Zoo": PettingZoo,
					"Darkmoon~Hunter~Minion~3~3~3~Beast~Darkmoon Strider~Uncollectible": DarkmoonStrider,
					"Darkmoon~Hunter~Weapon~4~2~2~Rinling's Rifle~Legendary": RinlingsRifle,
					"Darkmoon~Hunter~Minion~5~5~5~Beast~Trampling Rhino~Rush": TramplingRhino,
					"Darkmoon~Hunter~Minion~6~4~4~None~Maxima Blastenheimer~Battlecry~Legendary": MaximaBlastenheimer,
					"Darkmoon~Hunter~Minion~7~8~5~Mech~Darkmoon Tonk~Deathrattle": DarkmoonTonk,
					"Darkmoon~Hunter~Spell~8~Jewel of N'Zoth": JewelofNZoth,
					#Mage Cards
					"Darkmoon~Mage~Minion~2~3~2~Elemental~Confection Cyclone~Battlecry": ConfectionCyclone,
					"Darkmoon~Mage~Minion~1~1~2~Elemental~Sugar Elemental~Uncollectible": SugarElemental,
					"Darkmoon~Mage~Spell~2~Deck of Lunacy~Legendary": DeckofLunacy,
					"Darkmoon~Mage~Minion~2~2~3~None~Game Master": GameMaster,
					"Darkmoon~Mage~Spell~3~Rigged Faire Game~~Secret": RiggedFaireGame,
					"Darkmoon~Mage~Minion~4~4~4~None~Occult Conjurer~Battlecry": OccultConjurer,
					"Darkmoon~Mage~Spell~4~Ring Toss": RingToss,
					"Darkmoon~Mage~Spell~4~Ring Toss~Corrupted~Uncollectible": RingToss_Corrupt,
					"Darkmoon~Mage~Minion~5~3~5~Elemental~Firework Elemental~Battlecry": FireworkElemental,
					"Darkmoon~Mage~Minion~5~3~5~Elemental~Firework Elemental~Battlecry~Corrupted~Uncollectible": FireworkElemental_Corrupt,
					"Darkmoon~Mage~Minion~6~5~5~None~Sayge, Seer of Darkmoon~Battlecry~Legendary": SaygeSeerofDarkmoon,
					"Darkmoon~Mage~Spell~7~Mask of C'Thun": MaskofCThun,
					"Darkmoon~Mage~Spell~8~Grand Finale": GrandFinale,
					"Darkmoon~Mage~Minion~8~8~8~Elemental~Exploding Sparkler~Uncollectible": ExplodingSparkler,
					#Paladin Cards
					"Darkmoon~Paladin~Spell~1~Oh My Yogg!~~Secret": OhMyYogg,
					"Darkmoon~Paladin~Minion~2~2~3~Murloc~Redscale Dragontamer~Battlecry": RedscaleDragontamer,
					"Darkmoon~Paladin~Spell~2~Snack Run": SnackRun,
					"Darkmoon~Paladin~Minion~3~3~2~None~Carnival Barker": CarnivalBarker,
					"Darkmoon~Paladin~Spell~3~Day at the Faire": DayattheFaire,
					"Darkmoon~Paladin~Spell~3~Day at the Faire~Corrupted~Uncollectible": DayattheFaire_Corrupt,
					"Darkmoon~Paladin~Minion~4~3~5~None~Balloon Merchant~Battlecry": BalloonMerchant,
					"Darkmoon~Paladin~Minion~5~5~5~Mech~Carousel Gryphon~Divine Shield": CarouselGryphon,
					"Darkmoon~Paladin~Minion~5~8~8~Mech~Carousel Gryphon~Divine Shield~Taunt~Corrupted~Uncollectible": CarouselGryphon_Corrupt,
					"Darkmoon~Paladin~Minion~5~5~5~Demon~Lothraxion the Redeemed~Battlecry~Legendary": LothraxiontheRedeemed,
					"Darkmoon~Paladin~Weapon~6~3~3~Hammer of the Naaru~Battlecry": HammeroftheNaaru,
					"Darkmoon~Paladin~Minion~6~6~6~Elemental~Holy Elemental~Taunt~Uncollectible": HolyElemental,
					"Darkmoon~Paladin~Minion~8~7~5~None~High Exarch Yrel~Battlecry~Legendary": HighExarchYrel,
					#Priest Cards
					"Darkmoon~Priest~Spell~2~Insight": Insight,
					"Darkmoon~Priest~Spell~2~Insight~Corrupted~Uncollectible": Insight_Corrupt,
					"Darkmoon~Priest~Minion~3~4~3~None~Fairground Fool~Taunt": FairgroundFool,
					"Darkmoon~Priest~Minion~3~4~7~None~Fairground Fool~Taunt~Corrupted~Uncollectible": FairgroundFool_Corrupt,
					"Darkmoon~Priest~Minion~3~2~5~None~Nazmani Bloodweaver": NazmaniBloodweaver,
					"Darkmoon~Priest~Spell~3~Palm Reading": PalmReading,
					"Darkmoon~Priest~Spell~4~Auspicious Spirits": AuspiciousSpirits,
					"Darkmoon~Priest~Spell~4~Auspicious Spirits~Corrupted~Uncollectible": AuspiciousSpirits_Corrupt,
					"Darkmoon~Priest~Minion~4~4~4~None~The Nameless One~Battlecry~Legendary": TheNamelessOne,
					"Darkmoon~Priest~Minion~5~3~3~Mech~Fortune Teller~Taunt~Battlecry": FortuneTeller,
					"Darkmoon~Priest~Spell~8~Idol of Y'Shaarj": IdolofYShaarj,
					"Darkmoon~Priest~Minion~8~8~8~None~G'huun the Blood God~Battlecry~Legendary": GhuuntheBloodGod,
					"Darkmoon~Priest~Minion~9~8~8~Elemental~Blood of G'huun~Taunt": BloodofGhuun,
					#Rogue Cards
					"Darkmoon~Rogue~Minion~1~2~1~Pirate~Prize Plunderer~Combo": PrizePlunderer,
					"Darkmoon~Rogue~Minion~2~3~2~None~Foxy Fraud~Battlecry": FoxyFraud,
					"Darkmoon~Rogue~Spell~2~Shadow Clone~~Secret": ShadowClone,
					"Darkmoon~Rogue~Minion~2~3~2~None~Sweet Tooth": SweetTooth,
					"Darkmoon~Priest~Minion~2~5~2~None~Sweet Tooth~Stealth~Corrupted~Uncollectible": SweetTooth_Corrupt,
					"Darkmoon~Rogue~Spell~2~Swindle~Combo": Swindle,
					"Darkmoon~Rogue~Minion~2~3~2~None~Tenwu of the Red Smoke~Battlecry~Legendary": TenwuoftheRedSmoke,
					"Darkmoon~Rogue~Spell~3~Cloak of Shadows": CloakofShadows,
					"Darkmoon~Rogue~Minion~3~4~3~None~Ticket Master~Battlecry": TicketMaster,
					"Darkmoon~Rogue~Spell~3~Tickets~Casts When Drawn~Uncollectible": Tickets,
					"Darkmoon~Rogue~Minion~3~3~3~None~Plush Bear~Uncollectible": PlushBear,
					"Darkmoon~Rogue~Spell~5~Malevolent Strike": MalevolentStrike,
					"Darkmoon~Rogue~Minion~6~5~7~None~Grand Empress Shek'zara~Battlecry~Legendary": GrandEmpressShekzara,
					#Shaman Cards
					"Darkmoon~Shaman~Spell~1~Revolve": Revolve,
					"Darkmoon~Shaman~Minion~2~2~2~Elemental~Cagematch Custodian~Battlecry": CagematchCustodian,
					"Darkmoon~Shaman~Spell~2~Deathmatch Pavilion": DeathmatchPavilion,
					"Darkmoon~Shaman~Minion~2~3~2~None~Pavilion Duelist~Uncollectible": PavilionDuelist,
					"Darkmoon~Shaman~Minion~3~0~4~Totem~Grand Totem Eys'or~Legendary": GrandTotemEysor,
					"Darkmoon~Shaman~Minion~3~3~4~Murloc~Magicfin": Magicfin,
					"Darkmoon~Shaman~Minion~3~1~2~None~Pit Master~Battlecry": PitMaster,
					"Darkmoon~Shaman~Minion~3~1~2~None~Pit Master~Battlecry~Corrupted~Uncollectible": PitMaster_Corrupt,
					"Darkmoon~Shaman~Spell~3~Stormstrike": Stormstrike,
					"Darkmoon~Shaman~Weapon~3~3~2~Whack-A-Gnoll Hammer": WhackAGnollHammer,
					"Darkmoon~Shaman~Spell~4~Dunk Tank": DunkTank,
					"Darkmoon~Shaman~Spell~4~Dunk Tank~Corrupted~Uncollectible": DunkTank_Corrupt,
					"Darkmoon~Shaman~Minion~5~4~5~None~Inara Stormcrash~Legendary": InaraStormcrash,
					#Warlock Cards
					"Darkmoon~Warlock~Spell~1~Wicked Whispers": WickedWhispers,
					"Darkmoon~Warlock~Minion~2~1~5~Demon~Midway Maniac~Taunt": MidwayManiac,
					"Darkmoon~Warlock~Spell~3~Free Admission": FreeAdmission,
					"Darkmoon~Warlock~Minion~3~3~4~Demon~Man'ari Mosher~Battlecry": ManariMosher,
					"Darkmoon~Warlock~Spell~4~Cascading Disaster": CascadingDisaster,
					"Darkmoon~Warlock~Spell~4~Cascading Disaster~Corrupted~Uncollectible": CascadingDisaster_Corrupt,
					"Darkmoon~Warlock~Spell~4~Cascading Disaster~Corrupted~Uncollectible": CascadingDisaster_Corrupt2,
					"Darkmoon~Warlock~Minion~3~3~3~None~Revenant Rascal~Battlecry": RevenantRascal,
					"Darkmoon~Warlock~Minion~4~4~3~Demon~Fire Breather~Battlecry": FireBreather,
					"Darkmoon~Warlock~Spell~6~Deck of Chaos~Legendary": DeckofChaos,
					"Darkmoon~Warlock~Minion~6~6~4~Demon~Ring Matron~Taunt~Deathrattle": RingMatron,
					"Darkmoon~Warlock~Minion~2~3~2~Demon~Fiery Imp~Uncollectible": FieryImp,
					"Darkmoon~Warlock~Minion~6~8~8~Demon~Tickatus~Battlecry~Legendary": Tickatus,
					"Darkmoon~Warlock~Minion~6~8~8~Demon~Tickatus~Battlecry~Corrupted~Legendary~Uncollectible": Tickatus_Corrupt,
					#Warrior Cards
					"Darkmoon~Warrior~Spell~1~Stage Dive": StageDive,
					"Darkmoon~Warrior~Spell~1~Stage Dive~Corrupted~Uncollectible": StageDive_Corrupt,
					"Darkmoon~Warrior~Minion~2~1~3~Mech~Bumper Car~Rush~Deathrattle": BumperCar,
					"Darkmoon~Warrior~Minion~2~1~4~None~E.T.C., God of Metal~Legendary": ETCGodofMetal,
					"Darkmoon~Warrior~Spell~2~Minefield": Minefield,
					"Darkmoon~Warrior~Weapon~2~1~3~Ringmaster's Baton": RingmastersBaton,
					"Darkmoon~Warrior~Minion~2~3~2~Mech~Stage Hand~Battlecry": StageHand,
					"Darkmoon~Warrior~Spell~3~Feat of Strength": FeatofStrength,
					"Darkmoon~Warrior~Minion~4~2~5~Pirate~Sword Eater~Taunt~Battlecry": SwordEater,
					"Darkmoon~Warrior~Weapon~3~3~2~Jawbreaker~Uncollectible": Jawbreaker,
					"Darkmoon~Warrior~Minion~5~3~5~None~Ringmaster Whatley~Battlecry~Legendary": RingmasterWhatley,
					"Darkmoon~Warrior~Minion~5~5~5~Dragon~Tent Trasher~Rush": TentTrasher,
					}